# IIMP â€” Inter/Intra Organization Messaging Protocol

### v0.1 Draft Specification (Academic Version)

---

# 1. Design Philosophy

## Goals

* Domain-authoritative federation (SMTP-style)
* Real-time IM semantics
* Cursor-based client sync (IMAP-style)
* Simplified End-to-End Encryption
* Linear message model (no DAG, no distributed state resolution)
* Open federation by default
* Government / sovereign deployable
* No third-party dependency

## Non-Goals (v1)

* Forward secrecy
* Multi-device ratcheting
* Global room state resolution
* Byzantine fault tolerance
* Anonymous messaging
* Decentralized trust web

---

# 2. Identity Model

### User Identifier Format

```
<local-part>@<domain>
```

Example:

```
alice@org1.gov
bob@org2.edu
```

* Domain = authority
* Only the domain server can authenticate its users

---

# 3. Server Discovery

When sending to `bob@org2.edu`:

### Step 1 â€” DNS SRV Lookup

```
_iimp._tcp.org2.edu
```

If found:

* Use host + port

### Step 2 â€” Fallback

```
GET https://org2.edu/.well-known/iimp
```

Returns:

```
{
  "federation_endpoint": "https://federation.org2.edu",
  "api_endpoint": "https://api.org2.edu",
  "public_key": "...",
  "capabilities": [...]
}
```

Cache result.

---

# 4. Cryptography Model (Simplified E2E)

## Per User Keys

Each user has:

* Identity key (Ed25519)
* Encryption key (X25519 or RSA)

Public keys exposed via:

```
GET /.well-known/iimp/keys/{user}
```

---

## Message Encryption Flow

1. Generate random AES-256 symmetric key
2. Encrypt message body
3. For each recipient:

   * Encrypt symmetric key using recipient public key
4. Attach encrypted keys bundle

No:

* Prekeys
* Ratchets
* Forward secrecy
* Device bundles

Single-device assumption.

---

# 5. Message Model

## Message Structure

```
{
  message_id: UUIDv7,
  conversation_id: UUIDv7,
  sender: "alice@org1.com",
  participants: [ ... ],
  timestamp: int64,
  type: "text" | "edit",
  reference: message_id | null,
  encrypted_payload: blob,
  encrypted_keys: [
      {
         recipient: "bob@org2.edu",
         encrypted_key: "..."
      }
  ]
}
```

---

## Rules

* UUIDv7 ensures global uniqueness
* Immutable original messages
* Edits allowed:

  * max 3 edits
  * edit references original message_id
* No hard delete (optional soft delete in future)

---

# 6. Conversation Model

* conversation_id = UUIDv7
* Generated by sender at conversation creation
* Globally unique
* Group conversations allowed
* Participants list stored on each server

v1 Simplifications:

* No dynamic role system
* No moderator system
* No membership history tracking

---

# 7. Federation Model (SMTP-style)

## Federation Endpoint

```
POST /federation/v1/messages
```

Server-to-server only.

Signed HTTP request required.

---

## Federation Flow

1. Sender server receives message
2. Identify external domains
3. Queue outbound message
4. Discover recipient server
5. POST signed request
6. Recipient:

   * Verify signature
   * Validate structure
   * Store message
   * Return 200

---

## Retry Strategy

* Exponential backoff
* Persistent retry queue
* Max retry duration configurable
* After failure threshold:

  * Generate delivery failure notice

At-least-once delivery.
Idempotency via message_id.

---

# 8. Client Sync Model (IMAP-style)

Clients poll:

```
GET /api/v1/sync?cursor=<value>
```

Response:

```
{
  next_cursor: 12350,
  messages: [...]
}
```

Cursor:

* Monotonic per-user sequence number
* Assigned at delivery time

No WebSockets required in v1.

---

# 9. Attachments

## Upload

Client uploads to home server.

Server:

* Stores locally
* Generates attachment_id

---

## Federation

Receiving server pulls attachment:

```
GET /federation/v1/attachments/{id}
```

Result:

* Stored locally
* No cross-server hotlinking

Max message text size: 64KB.

---

# 10. Security Model

## Trust Assumptions

* Domain server is trusted for:

  * User authentication
  * Key authenticity
* Federation signed per request
* HTTPS required

## Replay Protection

* Reject duplicate message_id
* Signature expiration window

## Rate Limiting

* Per IP
* Per domain
* Per user

---

# 11. Open Federation Policy

Default:

* Accept all domains
  Admin can:
* Block specific domains
* Restrict federation entirely

---

# 12. Scalability Characteristics

* No global consensus
* No distributed state resolution
* No event DAG
* Per-conversation linear storage
* Per-user cursor indexing

Scales similarly to email.

---

# 13. Known Limitations (Honest Section)

* No forward secrecy
* Single-device assumption
* Domain-level trust model
* No Byzantine resilience
* No dynamic membership audit trail

---

# 14. Academic Positioning

Compared to:

* Matrix â†’ avoids DAG complexity
* XMPP â†’ simpler E2E model
* SMTP â†’ real-time semantics added
* Centralized IM â†’ sovereignty preserved

---

# 15. Future Work

* Forward secrecy
* Multi-device support
* WebSocket push
* Capability negotiation
* Formal threat model analysis

---

# ðŸš€ How Your Team Should Use This

Your teammates can now:

* Ask AI about any subsection
* Generate spec.go definitions
* Design DB schema
* Implement federation handlers
* Draft research sections
* Write evaluation benchmarks

This becomes the single source of truth.