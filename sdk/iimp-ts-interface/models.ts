
/**
* This file is auto-generated by Napiway. Do not edit this file directly.
* To make changes, edit the template file at generators/typescript/templates/models.ts.tmpl
*/


/**
 * IIMPError is a custom error class that encapsulates different types of errors that can occur when using the IIMP client. It includes a reason for the error, a message, and optionally the underlying error object for more detailed debugging information.
 */
export class IIMPError extends Error {
  reason: IIMPErrorReason;
  underlyingError?: Error; // Optional field to hold the original error object, if available

  constructor(reason: IIMPErrorReason, message: string, error?: Error) {
    super(message);
    this.reason = reason;
    this.underlyingError = error;
    if (error) {
      this.stack = error.stack; // Preserve original stack trace if available
    }
  }
}

export type IIMPErrorReason =
  | "invalid_request"
  | "decode_error"
  | "network_error"
  | "other_error";

export const IIMPErrorReasonInvalidRequest = "invalid_request";
export const IIMPErrorReasonDecodeError = "decode_error";
export const IIMPErrorReasonNetworkError = "network_error";
export const IIMPErrorReasonOtherError = "other_error";





const AddPublicKeyRequestHTTPMethod = "POST";
const AddPublicKeyRequestRoutePath   = "/api/client/keys";

/**
 * Add a new public key for end-to-end encryption.
 */
export type AddPublicKeyRequest = {




  /**
  * Authentication parameters
  */
  Auth: AddPublicKeyRequestAuthParams;


  /**
  * Request body
  */
  Body: AddPublicKeyRequestBody;

}



export type AddPublicKeyRequestBody = {
  
  /**
  * The public key to be added for end-to-end encryption. The key should be Base64URL Encoded X25519 Key.
  * Required
  *  Must be non-empty
  */
  PublicKey: string;

}




export type AddPublicKeyRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateAddPublicKeyRequest(req: AddPublicKeyRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateAddPublicKeyRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateAddPublicKeyRequestBody(o: AddPublicKeyRequestBody) : IIMPError | null {
  
  
  
  if (o.PublicKey.trim() === "") {
    throw new Error("Field 'PublicKey' must be non-empty");
  }
  
  
  
  
  return null;
}






export type AddPublicKey201Response = {
  

  
  /**
   * Response body
   */
  Body: AddPublicKey201ResponseBody;
  
}



export type AddPublicKey201ResponseBody = {
  
  /**
  * A unique identifier for the uploaded public key. This ID can be used to reference the key in future operations, such as encrypting messages for specific recipients or managing keys.
  * Required
  *  Must be non-empty
  */
  KeyId: string;

  /**
  * The timestamp when the public key was uploaded to the server. This can be used to determine the age of the key and manage key rotation policies.
  * Required
  * 
  */
  UploadedAt: string;

}




export async function NewAddPublicKey201Response(resp: Response): Promise<AddPublicKey201Response> {
  var result = {} as AddPublicKey201Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type AddPublicKey400Response = {
  

  
}




export async function NewAddPublicKey400Response(resp: Response): Promise<AddPublicKey400Response> {
  var result = {} as AddPublicKey400Response;

  

  
  return result
}


export type AddPublicKey401Response = {
  

  
}




export async function NewAddPublicKey401Response(resp: Response): Promise<AddPublicKey401Response> {
  var result = {} as AddPublicKey401Response;

  

  
  return result
}


export type AddPublicKey500Response = {
  

  
}




export async function NewAddPublicKey500Response(resp: Response): Promise<AddPublicKey500Response> {
  var result = {} as AddPublicKey500Response;

  

  
  return result
}




const ConversationFederationRequestHTTPMethod = "POST";
const ConversationFederationRequestRoutePath   = "/api/federation/conversations";

/**
 * \"FEDERATION\" Create/Update a conversation from another server. This endpoint is used by other servers to create/update a conversation that includes users from the local server. UPSERT operation should be performed by the receiving server.
 */
export type ConversationFederationRequest = {




  /**
  * Authentication parameters
  */
  Auth: ConversationFederationRequestAuthParams;


  /**
  * Request body
  */
  Body: ConversationFederationRequestBody;

}



export type ConversationFederationRequestBody = {
  
  /**
  * A unique identifier for the conversation, typically a UUIDv7.
  * Required
  *  Must be non-empty
  */
  ConversationId: string;

  /**
  * An optional name for the conversation, which can be set by the client. This is not used for identification purposes and can be changed by the owner user at any time.
  * Optional
  * 
  */
  ConversationName: string | null;

  /**
  * The user ID of the owner of the conversation. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  ConversationOwnerId: string;

  /**
  * The timestamp when the conversation was created. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z").
  * Required
  *  Must be non-empty
  */
  CreatedAt: string;

  /**
  * A list of participants in the conversation. The owner of the conversation is also included in this list. Participants can be added or removed by the owner user. Contains at least 2 participants (including the owner) for a Direct Conversation and >2 participants for a Group Conversation.
  * Required
  *  Must be non-empty
  */
  Participants: Array<ConversationFederationRequestBodyParticipantsItem>;

}



export type ConversationFederationRequestBodyParticipantsItem = {
  
  /**
  * The unique identifier of the conversation that the participant is part of. This is typically a UUIDv7.
  * Required
  *  Must be non-empty
  */
  ConversationId: string;

  /**
  * The timestamp when the participant joined the conversation. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z").
  * Required
  *  Must be non-empty
  */
  JoinedAt: string;

  /**
  * The timestamp when the participant was removed from the conversation. This field is null if the participant is still part of the conversation. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). A removed participant will not receive new messages in the conversation but can still access the conversation history up until the time they were removed. Owner CANNOT be removed from the conversation.
  * Optional
  * 
  */
  RemovedAt: string | null;

  /**
  * This is the display name of the participant at the time they joined the conversation. This is not updated if the user changes their display name later. This field is included to provide context about the participant's identity within the conversation, even if their global display name changes over time. During federation, the owner's server contacts the participant's server to fetch the current display name of the participant, which is then stored as UserDisplayName in the conversation participant list. This allows the conversation to maintain a consistent display name for the participant, even if they change their display name globally on their server.
  * Required
  *  Must be non-empty
  */
  UserDisplayName: string;

  /**
  * User ID of the participant. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  UserId: string;

}




export type ConversationFederationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: Server JWT signed with the requesting server's private key. This token is used for authenticating requests between servers during federation. The receiving server will verify the token using the requesting server's public key, which can be obtained from the requesting server's JWKS endpoint. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateConversationFederationRequest(req: ConversationFederationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateConversationFederationRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateConversationFederationRequestBody(o: ConversationFederationRequestBody) : IIMPError | null {
  
  
  
  if (o.ConversationId.trim() === "") {
    throw new Error("Field 'ConversationId' must be non-empty");
  }
  
  
  
  
  
  
  
  
  
  if (o.ConversationOwnerId.trim() === "") {
    throw new Error("Field 'ConversationOwnerId' must be non-empty");
  }
  
  
  
  
  
  
  if (o.CreatedAt.trim() === "") {
    throw new Error("Field 'CreatedAt' must be non-empty");
  }
  
  
  
  
  
  
  if (o.Participants.length === 0) {
    throw new Error("Field 'Participants' must be non-empty");
  }
  
  
  
  for (let idx = 0; idx < o.Participants.length; idx++) {
    const item = o.Participants[idx];
    ValidateConversationFederationRequestBodyParticipantsItem(item);
  }
  
  
  return null;
}

function ValidateConversationFederationRequestBodyParticipantsItem(o: ConversationFederationRequestBodyParticipantsItem) : IIMPError | null {
  
  
  
  if (o.ConversationId.trim() === "") {
    throw new Error("Field 'ConversationId' must be non-empty");
  }
  
  
  
  
  
  
  if (o.JoinedAt.trim() === "") {
    throw new Error("Field 'JoinedAt' must be non-empty");
  }
  
  
  
  
  
  
  
  
  
  if (o.UserDisplayName.trim() === "") {
    throw new Error("Field 'UserDisplayName' must be non-empty");
  }
  
  
  
  
  
  
  if (o.UserId.trim() === "") {
    throw new Error("Field 'UserId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type ConversationFederation200Response = {
  

  
}




export async function NewConversationFederation200Response(resp: Response): Promise<ConversationFederation200Response> {
  var result = {} as ConversationFederation200Response;

  

  
  return result
}


export type ConversationFederation400Response = {
  

  
}




export async function NewConversationFederation400Response(resp: Response): Promise<ConversationFederation400Response> {
  var result = {} as ConversationFederation400Response;

  

  
  return result
}


export type ConversationFederation401Response = {
  

  
}




export async function NewConversationFederation401Response(resp: Response): Promise<ConversationFederation401Response> {
  var result = {} as ConversationFederation401Response;

  

  
  return result
}


export type ConversationFederation403Response = {
  

  
}




export async function NewConversationFederation403Response(resp: Response): Promise<ConversationFederation403Response> {
  var result = {} as ConversationFederation403Response;

  

  
  return result
}


export type ConversationFederation404Response = {
  

  
}




export async function NewConversationFederation404Response(resp: Response): Promise<ConversationFederation404Response> {
  var result = {} as ConversationFederation404Response;

  

  
  return result
}


export type ConversationFederation500Response = {
  

  
}




export async function NewConversationFederation500Response(resp: Response): Promise<ConversationFederation500Response> {
  var result = {} as ConversationFederation500Response;

  

  
  return result
}




const DiscoverServerRequestHTTPMethod = "GET";
const DiscoverServerRequestRoutePath   = "/.well-known/iimp";

/**
 * Retrieve information about the IIMP server, including protocol version, domain, and federation endpoint. This allows clients and other servers to discover the capabilities and federation details of the server.
 */
export type DiscoverServerRequest = {





}






export function ValidateDiscoverServerRequest(req: DiscoverServerRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  

  

  return null;
}







export type DiscoverServer200Response = {
  

  
  /**
   * Response body
   */
  Body: DiscoverServer200ResponseBody;
  
}



export type DiscoverServer200ResponseBody = {
  
  /**
  * Canonical domain name of the server.
  * Required
  *  Must be non-empty
  */
  Domain: string;

  /**
  * URL endpoint for federation with other IIMP servers.
  * Required
  *  Must be non-empty
  */
  FederationEndpoint: string;

  /**
  * IIMP protocol version supported by the server.
  * Required
  *  Must be non-empty
  */
  Version: string;

}




export async function NewDiscoverServer200Response(resp: Response): Promise<DiscoverServer200Response> {
  var result = {} as DiscoverServer200Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type DiscoverServer500Response = {
  

  
}




export async function NewDiscoverServer500Response(resp: Response): Promise<DiscoverServer500Response> {
  var result = {} as DiscoverServer500Response;

  

  
  return result
}




const EditMessageRequestHTTPMethod = "PUT";
const EditMessageRequestRoutePath   = "/api/client/conversations/{conversationId}/messages/{messageId}";

/**
 * Edit an existing message in a conversation. Only the sender of the message can edit it.
 */
export type EditMessageRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * The unique identifier of the conversation that the message belongs to. This is typically a UUIDv7.
  * 
  * Required
  */
  ConversationId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * The unique identifier of the message to edit. This is typically a UUIDv7
  * 
  * Required
  */
  MessageId: string;





  /**
  * Authentication parameters
  */
  Auth: EditMessageRequestAuthParams;


  /**
  * Request body
  */
  Body: EditMessageRequestBody;

}



export type EditMessageRequestBody = {
  
  /**
  * No description provided
  * Required
  * 
  */
  MessageContent: EditMessageRequestBodyMessageContent;

}



export type EditMessageRequestBodyMessageContent = {
  
  /**
  * The content of the message to be sent in the conversation. The content should be encrypted using an AES key, and the AES key should be encrypted for each recipient using their respective public keys. The server will store the encrypted message content and the encrypted keys for each recipient, allowing the recipients to decrypt the AES key using their private keys and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  Content: string;

  /**
  * Encryption details for the recipients of the message.
  * Required
  *  Must be non-empty
  */
  EncryptionData: Array<EditMessageRequestBodyMessageContentEncryptionDataItem>;

  /**
  * The nonce (or initialization vector) used in the AES encryption of the message content. This should be a unique value for each message encrypted with the same AES key to ensure security. The nonce is required for the decryption process, as it is used along with the AES key to decrypt the message content. The server will store the nonce along with the encrypted message content and deliver it to the recipients, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  Nonce: string;

  /**
  * The timestamp when the message content was created. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). This field is included to provide context about when the message content was created, which can be useful for ordering messages and displaying timestamps in the client applications.
  * Required
  *  Must be non-empty
  */
  Timestamp: string;

}



export type EditMessageRequestBodyMessageContentEncryptionDataItem = {
  
  /**
  * Encryption details for a recipient of the message.
  * Required
  * 
  */
  Encryption: EditMessageRequestBodyMessageContentEncryptionDataItemEncryption;

  /**
  * User ID of the recipient of the message. (localpart@domain). This field is included to associate the encryption details with the specific recipient, allowing the server to deliver the correct encrypted key and nonce to each recipient along with the encrypted message content.
  * Required
  *  Must be non-empty
  */
  RecipientId: string;

}



export type EditMessageRequestBodyMessageContentEncryptionDataItemEncryption = {
  
  /**
  * The AES key used to encrypt the message content, encrypted with the recipient's public key using an asymmetric encryption algorithm (X25519 + HKDF). The server will store this encrypted key and deliver it to the recipient along with the encrypted message content, allowing the recipient to decrypt the AES key using their private key and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  EncryptedKey: string;

  /**
  * The nonce used in the encryption of the AES key for this recipient. This should be a unique value for each encrypted key to ensure security. The server will store this nonce along with the encrypted key and deliver it to the recipient, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  EncryptedKeyNonce: string;

  /**
  * An ephemeral public key generated by the sender for this message, used in the encryption process (X25519).
  * Required
  *  Must be non-empty
  */
  EphemeralPublicKey: string;

  /**
  * The unique identifier of the public key that was used to encrypt the message for this recipient. This should correspond to a KeyId returned by the server when the client added their public keys.
  * Required
  *  Must be non-empty
  */
  KeyId: string;

}




export type EditMessageRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateEditMessageRequest(req: EditMessageRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateEditMessageRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateEditMessageRequestBody(o: EditMessageRequestBody) : IIMPError | null {
  
  
  
  
  ValidateEditMessageRequestBodyMessageContent(o.MessageContent);
  
  
  
  return null;
}

function ValidateEditMessageRequestBodyMessageContent(o: EditMessageRequestBodyMessageContent) : IIMPError | null {
  
  
  
  if (o.Content.trim() === "") {
    throw new Error("Field 'Content' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptionData.length === 0) {
    throw new Error("Field 'EncryptionData' must be non-empty");
  }
  
  
  
  for (let idx = 0; idx < o.EncryptionData.length; idx++) {
    const item = o.EncryptionData[idx];
    ValidateEditMessageRequestBodyMessageContentEncryptionDataItem(item);
  }
  
  
  
  
  if (o.Nonce.trim() === "") {
    throw new Error("Field 'Nonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.Timestamp.trim() === "") {
    throw new Error("Field 'Timestamp' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateEditMessageRequestBodyMessageContentEncryptionDataItem(o: EditMessageRequestBodyMessageContentEncryptionDataItem) : IIMPError | null {
  
  
  
  
  ValidateEditMessageRequestBodyMessageContentEncryptionDataItemEncryption(o.Encryption);
  
  
  
  
  
  if (o.RecipientId.trim() === "") {
    throw new Error("Field 'RecipientId' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateEditMessageRequestBodyMessageContentEncryptionDataItemEncryption(o: EditMessageRequestBodyMessageContentEncryptionDataItemEncryption) : IIMPError | null {
  
  
  
  if (o.EncryptedKey.trim() === "") {
    throw new Error("Field 'EncryptedKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptedKeyNonce.trim() === "") {
    throw new Error("Field 'EncryptedKeyNonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EphemeralPublicKey.trim() === "") {
    throw new Error("Field 'EphemeralPublicKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.KeyId.trim() === "") {
    throw new Error("Field 'KeyId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type EditMessage200Response = {
  

  
}




export async function NewEditMessage200Response(resp: Response): Promise<EditMessage200Response> {
  var result = {} as EditMessage200Response;

  

  
  return result
}


export type EditMessage400Response = {
  

  
}




export async function NewEditMessage400Response(resp: Response): Promise<EditMessage400Response> {
  var result = {} as EditMessage400Response;

  

  
  return result
}


export type EditMessage401Response = {
  

  
}




export async function NewEditMessage401Response(resp: Response): Promise<EditMessage401Response> {
  var result = {} as EditMessage401Response;

  

  
  return result
}


export type EditMessage403Response = {
  

  
}




export async function NewEditMessage403Response(resp: Response): Promise<EditMessage403Response> {
  var result = {} as EditMessage403Response;

  

  
  return result
}


export type EditMessage404Response = {
  

  
}




export async function NewEditMessage404Response(resp: Response): Promise<EditMessage404Response> {
  var result = {} as EditMessage404Response;

  

  
  return result
}


export type EditMessage500Response = {
  

  
}




export async function NewEditMessage500Response(resp: Response): Promise<EditMessage500Response> {
  var result = {} as EditMessage500Response;

  

  
  return result
}




const EditMessageForwardFederationRequestHTTPMethod = "PUT";
const EditMessageForwardFederationRequestRoutePath   = "/api/federation/conversations/{conversationId}/messages/{messageId}/edit/forward";

/**
 * \"FEDERATION\" Edit a message in a conversation on another server.
 */
export type EditMessageForwardFederationRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * Unique identifier of the conversation to edit the message in.
  * 
  * Required
  */
  ConversationId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * Unique identifier of the message to edit.
  * 
  * Required
  */
  MessageId: string;





  /**
  * Authentication parameters
  */
  Auth: EditMessageForwardFederationRequestAuthParams;


  /**
  * Request body
  */
  Body: EditMessageForwardFederationRequestBody;

}



export type EditMessageForwardFederationRequestBody = {
  
  /**
  * User ID of the sender of the message to edit. This should be in the format localpart@domain and must belong to the requesting server and should be equal to the sender's id on the receiving server's message.
  * Required
  *  Must be non-empty
  */
  SenderUserId: string;

  /**
  * Updated message details.
  * Required
  * 
  */
  UpdatedMessage: EditMessageForwardFederationRequestBodyUpdatedMessage;

}



export type EditMessageForwardFederationRequestBodyUpdatedMessage = {
  
  /**
  * No description provided
  * Required
  * 
  */
  MessageContent: EditMessageForwardFederationRequestBodyUpdatedMessageMessageContent;

}



export type EditMessageForwardFederationRequestBodyUpdatedMessageMessageContent = {
  
  /**
  * The content of the message to be sent in the conversation. The content should be encrypted using an AES key, and the AES key should be encrypted for each recipient using their respective public keys. The server will store the encrypted message content and the encrypted keys for each recipient, allowing the recipients to decrypt the AES key using their private keys and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  Content: string;

  /**
  * Encryption details for the recipients of the message.
  * Required
  *  Must be non-empty
  */
  EncryptionData: Array<EditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItem>;

  /**
  * The nonce (or initialization vector) used in the AES encryption of the message content. This should be a unique value for each message encrypted with the same AES key to ensure security. The nonce is required for the decryption process, as it is used along with the AES key to decrypt the message content. The server will store the nonce along with the encrypted message content and deliver it to the recipients, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  Nonce: string;

  /**
  * The timestamp when the message content was created. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). This field is included to provide context about when the message content was created, which can be useful for ordering messages and displaying timestamps in the client applications.
  * Required
  *  Must be non-empty
  */
  Timestamp: string;

}



export type EditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItem = {
  
  /**
  * Encryption details for a recipient of the message.
  * Required
  * 
  */
  Encryption: EditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItemEncryption;

  /**
  * User ID of the recipient of the message. (localpart@domain). This field is included to associate the encryption details with the specific recipient, allowing the server to deliver the correct encrypted key and nonce to each recipient along with the encrypted message content.
  * Required
  *  Must be non-empty
  */
  RecipientId: string;

}



export type EditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItemEncryption = {
  
  /**
  * The AES key used to encrypt the message content, encrypted with the recipient's public key using an asymmetric encryption algorithm (X25519 + HKDF). The server will store this encrypted key and deliver it to the recipient along with the encrypted message content, allowing the recipient to decrypt the AES key using their private key and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  EncryptedKey: string;

  /**
  * The nonce used in the encryption of the AES key for this recipient. This should be a unique value for each encrypted key to ensure security. The server will store this nonce along with the encrypted key and deliver it to the recipient, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  EncryptedKeyNonce: string;

  /**
  * An ephemeral public key generated by the sender for this message, used in the encryption process (X25519).
  * Required
  *  Must be non-empty
  */
  EphemeralPublicKey: string;

  /**
  * The unique identifier of the public key that was used to encrypt the message for this recipient. This should correspond to a KeyId returned by the server when the client added their public keys.
  * Required
  *  Must be non-empty
  */
  KeyId: string;

}




export type EditMessageForwardFederationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: Server JWT signed with the requesting server's private key. This token is used for authenticating requests between servers during federation. The receiving server will verify the token using the requesting server's public key, which can be obtained from the requesting server's JWKS endpoint. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateEditMessageForwardFederationRequest(req: EditMessageForwardFederationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateEditMessageForwardFederationRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateEditMessageForwardFederationRequestBody(o: EditMessageForwardFederationRequestBody) : IIMPError | null {
  
  
  
  if (o.SenderUserId.trim() === "") {
    throw new Error("Field 'SenderUserId' must be non-empty");
  }
  
  
  
  
  
  
  
  ValidateEditMessageForwardFederationRequestBodyUpdatedMessage(o.UpdatedMessage);
  
  
  
  return null;
}

function ValidateEditMessageForwardFederationRequestBodyUpdatedMessage(o: EditMessageForwardFederationRequestBodyUpdatedMessage) : IIMPError | null {
  
  
  
  
  ValidateEditMessageForwardFederationRequestBodyUpdatedMessageMessageContent(o.MessageContent);
  
  
  
  return null;
}

function ValidateEditMessageForwardFederationRequestBodyUpdatedMessageMessageContent(o: EditMessageForwardFederationRequestBodyUpdatedMessageMessageContent) : IIMPError | null {
  
  
  
  if (o.Content.trim() === "") {
    throw new Error("Field 'Content' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptionData.length === 0) {
    throw new Error("Field 'EncryptionData' must be non-empty");
  }
  
  
  
  for (let idx = 0; idx < o.EncryptionData.length; idx++) {
    const item = o.EncryptionData[idx];
    ValidateEditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItem(item);
  }
  
  
  
  
  if (o.Nonce.trim() === "") {
    throw new Error("Field 'Nonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.Timestamp.trim() === "") {
    throw new Error("Field 'Timestamp' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateEditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItem(o: EditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItem) : IIMPError | null {
  
  
  
  
  ValidateEditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItemEncryption(o.Encryption);
  
  
  
  
  
  if (o.RecipientId.trim() === "") {
    throw new Error("Field 'RecipientId' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateEditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItemEncryption(o: EditMessageForwardFederationRequestBodyUpdatedMessageMessageContentEncryptionDataItemEncryption) : IIMPError | null {
  
  
  
  if (o.EncryptedKey.trim() === "") {
    throw new Error("Field 'EncryptedKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptedKeyNonce.trim() === "") {
    throw new Error("Field 'EncryptedKeyNonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EphemeralPublicKey.trim() === "") {
    throw new Error("Field 'EphemeralPublicKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.KeyId.trim() === "") {
    throw new Error("Field 'KeyId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type EditMessageForwardFederation200Response = {
  

  
}




export async function NewEditMessageForwardFederation200Response(resp: Response): Promise<EditMessageForwardFederation200Response> {
  var result = {} as EditMessageForwardFederation200Response;

  

  
  return result
}


export type EditMessageForwardFederation400Response = {
  

  
}




export async function NewEditMessageForwardFederation400Response(resp: Response): Promise<EditMessageForwardFederation400Response> {
  var result = {} as EditMessageForwardFederation400Response;

  

  
  return result
}


export type EditMessageForwardFederation401Response = {
  

  
}




export async function NewEditMessageForwardFederation401Response(resp: Response): Promise<EditMessageForwardFederation401Response> {
  var result = {} as EditMessageForwardFederation401Response;

  

  
  return result
}


export type EditMessageForwardFederation403Response = {
  

  
}




export async function NewEditMessageForwardFederation403Response(resp: Response): Promise<EditMessageForwardFederation403Response> {
  var result = {} as EditMessageForwardFederation403Response;

  

  
  return result
}


export type EditMessageForwardFederation404Response = {
  

  
}




export async function NewEditMessageForwardFederation404Response(resp: Response): Promise<EditMessageForwardFederation404Response> {
  var result = {} as EditMessageForwardFederation404Response;

  

  
  return result
}


export type EditMessageForwardFederation500Response = {
  

  
}




export async function NewEditMessageForwardFederation500Response(resp: Response): Promise<EditMessageForwardFederation500Response> {
  var result = {} as EditMessageForwardFederation500Response;

  

  
  return result
}




const FetchAttachmentBytesRequestHTTPMethod = "GET";
const FetchAttachmentBytesRequestRoutePath   = "/api/client/conversations/{conversationId}/messages/{messageId}/attachments/{attachmentId}/bytes";

/**
 * Fetch the bytes of an attachment for a message in a conversation. This is a NOOP endpoint for documentation, since the actual fetching of the attachment bytes is to be done by the client.
 */
export type FetchAttachmentBytesRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * The unique identifier of the conversation that the message belongs to. This is typically a UUIDv7.
  * 
  * Required
  */
  ConversationId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * The unique identifier of the message that the attachment belongs to. This is typically a UUIDv7.
  * 
  * Required
  */
  MessageId: string;


  /**
  * Source: path parameter "{attachmentId}"
  
  * The unique identifier of the attachment to fetch. This is typically a UUIDv7 and should correspond to an attachment that was previously uploaded to the server using the NewAttachment endpoint.
  * 
  * Required
  */
  AttachmentId: string;





  /**
  * Authentication parameters
  */
  Auth: FetchAttachmentBytesRequestAuthParams;


}




export type FetchAttachmentBytesRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateFetchAttachmentBytesRequest(req: FetchAttachmentBytesRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}







export type FetchAttachmentBytes200Response = {
  

  
}




export async function NewFetchAttachmentBytes200Response(resp: Response): Promise<FetchAttachmentBytes200Response> {
  var result = {} as FetchAttachmentBytes200Response;

  

  
  return result
}


export type FetchAttachmentBytes400Response = {
  

  
}




export async function NewFetchAttachmentBytes400Response(resp: Response): Promise<FetchAttachmentBytes400Response> {
  var result = {} as FetchAttachmentBytes400Response;

  

  
  return result
}


export type FetchAttachmentBytes401Response = {
  

  
}




export async function NewFetchAttachmentBytes401Response(resp: Response): Promise<FetchAttachmentBytes401Response> {
  var result = {} as FetchAttachmentBytes401Response;

  

  
  return result
}


export type FetchAttachmentBytes403Response = {
  

  
}




export async function NewFetchAttachmentBytes403Response(resp: Response): Promise<FetchAttachmentBytes403Response> {
  var result = {} as FetchAttachmentBytes403Response;

  

  
  return result
}


export type FetchAttachmentBytes404Response = {
  

  
}




export async function NewFetchAttachmentBytes404Response(resp: Response): Promise<FetchAttachmentBytes404Response> {
  var result = {} as FetchAttachmentBytes404Response;

  

  
  return result
}


export type FetchAttachmentBytes500Response = {
  

  
}




export async function NewFetchAttachmentBytes500Response(resp: Response): Promise<FetchAttachmentBytes500Response> {
  var result = {} as FetchAttachmentBytes500Response;

  

  
  return result
}




const FetchAttachmentBytesFederationRequestHTTPMethod = "GET";
const FetchAttachmentBytesFederationRequestRoutePath   = "/api/federation/conversations/{conversationId}/messages/{messageId}/attachments/{attachmentId}/bytes";

/**
 * \"FEDERATION\" Fetch the bytes of an attachment from another server. This is a noop endpoint for documentation purposes, the server should implement fetching the actual bytes using the provided endpoint. Server must implement this, requesting server needs to fetch the bytes NOT using the SDK.
 */
export type FetchAttachmentBytesFederationRequest = {

  /**
  * Source: path parameter "{attachmentId}"
  
  * Unique identifier of the attachment to fetch.
  * 
  * Required
  */
  AttachmentId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * Unique identifier of the message that the attachment belongs to.
  * 
  * Required
  */
  MessageId: string;


  /**
  * Source: path parameter "{conversationId}"
  
  * Unique identifier of the conversation that the message belongs to.
  * 
  * Required
  */
  ConversationId: string;





  /**
  * Authentication parameters
  */
  Auth: FetchAttachmentBytesFederationRequestAuthParams;


}




export type FetchAttachmentBytesFederationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: Server JWT signed with the requesting server's private key. This token is used for authenticating requests between servers during federation. The receiving server will verify the token using the requesting server's public key, which can be obtained from the requesting server's JWKS endpoint. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateFetchAttachmentBytesFederationRequest(req: FetchAttachmentBytesFederationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}







export type FetchAttachmentBytesFederation200Response = {
  

  
}




export async function NewFetchAttachmentBytesFederation200Response(resp: Response): Promise<FetchAttachmentBytesFederation200Response> {
  var result = {} as FetchAttachmentBytesFederation200Response;

  

  
  return result
}


export type FetchAttachmentBytesFederation400Response = {
  

  
}




export async function NewFetchAttachmentBytesFederation400Response(resp: Response): Promise<FetchAttachmentBytesFederation400Response> {
  var result = {} as FetchAttachmentBytesFederation400Response;

  

  
  return result
}


export type FetchAttachmentBytesFederation401Response = {
  

  
}




export async function NewFetchAttachmentBytesFederation401Response(resp: Response): Promise<FetchAttachmentBytesFederation401Response> {
  var result = {} as FetchAttachmentBytesFederation401Response;

  

  
  return result
}


export type FetchAttachmentBytesFederation403Response = {
  

  
}




export async function NewFetchAttachmentBytesFederation403Response(resp: Response): Promise<FetchAttachmentBytesFederation403Response> {
  var result = {} as FetchAttachmentBytesFederation403Response;

  

  
  return result
}


export type FetchAttachmentBytesFederation404Response = {
  

  
}




export async function NewFetchAttachmentBytesFederation404Response(resp: Response): Promise<FetchAttachmentBytesFederation404Response> {
  var result = {} as FetchAttachmentBytesFederation404Response;

  

  
  return result
}


export type FetchAttachmentBytesFederation500Response = {
  

  
}




export async function NewFetchAttachmentBytesFederation500Response(resp: Response): Promise<FetchAttachmentBytesFederation500Response> {
  var result = {} as FetchAttachmentBytesFederation500Response;

  

  
  return result
}




const GetJWKSStoreRequestHTTPMethod = "GET";
const GetJWKSStoreRequestRoutePath   = "/.well-known/iimp/jwks";

/**
 * Retrieve the JSON Web Key Set (JWKS) containing the public keys used by the server for verifying signatures. This is used in the federation process to ensure secure communication between servers.
 */
export type GetJWKSStoreRequest = {





}






export function ValidateGetJWKSStoreRequest(req: GetJWKSStoreRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  

  

  return null;
}







export type GetJWKSStore200Response = {
  

  
  /**
   * Response body
   */
  Body: GetJWKSStore200ResponseBody;
  
}



export type GetJWKSStore200ResponseBodyKeysItem = {
  
  /**
  * The algorithm used with this key. For example, "RS256" or "EdDSA".
  * Required
  *  Must be non-empty
  */
  Alg: string;

  /**
  * Elliptic curve name (e.g., "Ed25519" or "X25519"). Required if Kty is "OKP".
  * Optional
  * 
  */
  Crv: string | null;

  /**
  * RSA public exponent (base64url encoded). Required if Kty is "RSA".
  * Optional
  * 
  */
  E: string | null;

  /**
  * Unique identifier for the key. Used to match the 'kid' field in JWT headers.
  * Required
  *  Must be non-empty
  */
  Kid: string;

  /**
  * The key type. For example, "RSA" or "OKP".
  * Required
  *  Must be non-empty
  */
  Kty: string;

  /**
  * RSA modulus (base64url encoded). Required if Kty is "RSA".
  * Optional
  * 
  */
  N: string | null;

  /**
  * The intended use of the key. Typically "sig" for signature verification.
  * Required
  *  Must be non-empty
  */
  Use: string;

  /**
  * Public key value (base64url encoded). Required if Kty is "OKP".
  * Optional
  * 
  */
  X: string | null;

}



export type GetJWKSStore200ResponseBody = {
  
  /**
  * A list of JSON Web Keys (JWK) used to verify signatures issued by this server.
  * Required
  *  Must be non-empty
  */
  Keys: Array<GetJWKSStore200ResponseBodyKeysItem>;

}




export async function NewGetJWKSStore200Response(resp: Response): Promise<GetJWKSStore200Response> {
  var result = {} as GetJWKSStore200Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type GetJWKSStore500Response = {
  

  
}




export async function NewGetJWKSStore500Response(resp: Response): Promise<GetJWKSStore500Response> {
  var result = {} as GetJWKSStore500Response;

  

  
  return result
}




const GetUserInfoFederationRequestHTTPMethod = "GET";
const GetUserInfoFederationRequestRoutePath   = "/api/federation/users/{userId}";

/**
 * \"FEDERATION\" Retrieve information about a user for federation purposes. This endpoint is used by other servers to fetch details about a user, such as their display name and more.
 */
export type GetUserInfoFederationRequest = {

  /**
  * Source: path parameter "{userId}"
  
  * Unique identifier of the user whose information is being requested. This should be in the format localpart@domain.
  * 
  * Required
  */
  UserId: string;





  /**
  * Authentication parameters
  */
  Auth: GetUserInfoFederationRequestAuthParams;


}




export type GetUserInfoFederationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: Server JWT signed with the requesting server's private key. This token is used for authenticating requests between servers during federation. The receiving server will verify the token using the requesting server's public key, which can be obtained from the requesting server's JWKS endpoint. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateGetUserInfoFederationRequest(req: GetUserInfoFederationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}







export type GetUserInfoFederation200Response = {
  

  
  /**
   * Response body
   */
  Body: GetUserInfoFederation200ResponseBody;
  
}



export type GetUserInfoFederation200ResponseBody = {
  
  /**
  * Display name of the user.
  * Required
  *  Must be non-empty
  */
  DisplayName: string;

  /**
  * User ID of the user. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  UserId: string;

}




export async function NewGetUserInfoFederation200Response(resp: Response): Promise<GetUserInfoFederation200Response> {
  var result = {} as GetUserInfoFederation200Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type GetUserInfoFederation401Response = {
  

  
}




export async function NewGetUserInfoFederation401Response(resp: Response): Promise<GetUserInfoFederation401Response> {
  var result = {} as GetUserInfoFederation401Response;

  

  
  return result
}


export type GetUserInfoFederation404Response = {
  

  
}




export async function NewGetUserInfoFederation404Response(resp: Response): Promise<GetUserInfoFederation404Response> {
  var result = {} as GetUserInfoFederation404Response;

  

  
  return result
}


export type GetUserInfoFederation500Response = {
  

  
}




export async function NewGetUserInfoFederation500Response(resp: Response): Promise<GetUserInfoFederation500Response> {
  var result = {} as GetUserInfoFederation500Response;

  

  
  return result
}




const GetUserPublicKeyRequestHTTPMethod = "GET";
const GetUserPublicKeyRequestRoutePath   = "/.well-known/iimp/keys/users/{userId}";

/**
 * Retrieve the public key associated with a specific user.
 */
export type GetUserPublicKeyRequest = {

  /**
  * Source: path parameter "{userId}"
  
  * Unique identifier of the user whose public key is being requested. This should be in the format localpart@domain.
  * 
  * Required
  */
  UserId: string;






}






export function ValidateGetUserPublicKeyRequest(req: GetUserPublicKeyRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  

  

  return null;
}







export type GetUserPublicKey200Response = {
  

  
  /**
   * Response body
   */
  Body: GetUserPublicKey200ResponseBody;
  
}



export type GetUserPublicKey200ResponseBody = {
  
  /**
  * Unique identifier for the public key.
  * Required
  *  Must be non-empty
  */
  KeyId: string;

  /**
  * The actual public key data, encoded in a suitable format (X25519 public key encoded in Base64URL format).
  * Required
  *  Must be non-empty
  */
  PublicKey: string;

  /**
  * Timestamp indicating when the public key was uploaded, in ISO 8601 format.
  * Required
  *  Must be non-empty
  */
  UploadedAt: string;

  /**
  * Unique identifier of the user to whom the public key belongs. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  UserId: string;

}




export async function NewGetUserPublicKey200Response(resp: Response): Promise<GetUserPublicKey200Response> {
  var result = {} as GetUserPublicKey200Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type GetUserPublicKey404Response = {
  

  
}




export async function NewGetUserPublicKey404Response(resp: Response): Promise<GetUserPublicKey404Response> {
  var result = {} as GetUserPublicKey404Response;

  

  
  return result
}


export type GetUserPublicKey500Response = {
  

  
}




export async function NewGetUserPublicKey500Response(resp: Response): Promise<GetUserPublicKey500Response> {
  var result = {} as GetUserPublicKey500Response;

  

  
  return result
}




const GetUserPublicKeyByIdRequestHTTPMethod = "GET";
const GetUserPublicKeyByIdRequestRoutePath   = "/.well-known/iimp/keys/users/{userId}/{keyId}";

/**
 * Retrieve a specific public key associated with a user, identified by its key ID. Used for historical key retrieval.
 */
export type GetUserPublicKeyByIdRequest = {

  /**
  * Source: path parameter "{userId}"
  
  * Unique identifier of the user whose public key is being requested. This should be in the format localpart@domain.
  * 
  * Required
  */
  UserId: string;


  /**
  * Source: path parameter "{keyId}"
  
  * Unique identifier for the specific public key to retrieve. This allows clients to fetch historical keys if needed.
  * 
  * Required
  */
  KeyId: string;






}






export function ValidateGetUserPublicKeyByIdRequest(req: GetUserPublicKeyByIdRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  

  

  return null;
}







export type GetUserPublicKeyById200Response = {
  

  
  /**
   * Response body
   */
  Body: GetUserPublicKeyById200ResponseBody;
  
}



export type GetUserPublicKeyById200ResponseBody = {
  
  /**
  * Unique identifier for the public key.
  * Required
  *  Must be non-empty
  */
  KeyId: string;

  /**
  * The actual public key data, encoded in a suitable format (X25519 public key encoded in Base64URL format).
  * Required
  *  Must be non-empty
  */
  PublicKey: string;

  /**
  * Timestamp indicating when the public key was uploaded, in ISO 8601 format.
  * Required
  *  Must be non-empty
  */
  UploadedAt: string;

  /**
  * Unique identifier of the user to whom the public key belongs. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  UserId: string;

}




export async function NewGetUserPublicKeyById200Response(resp: Response): Promise<GetUserPublicKeyById200Response> {
  var result = {} as GetUserPublicKeyById200Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type GetUserPublicKeyById404Response = {
  

  
}




export async function NewGetUserPublicKeyById404Response(resp: Response): Promise<GetUserPublicKeyById404Response> {
  var result = {} as GetUserPublicKeyById404Response;

  

  
  return result
}


export type GetUserPublicKeyById500Response = {
  

  
}




export async function NewGetUserPublicKeyById500Response(resp: Response): Promise<GetUserPublicKeyById500Response> {
  var result = {} as GetUserPublicKeyById500Response;

  

  
  return result
}




const LoginRequestHTTPMethod = "POST";
const LoginRequestRoutePath   = "/api/client/login";

/**
 * Authenticate a user and establish a session.
 */
export type LoginRequest = {





  /**
  * Request body
  */
  Body: LoginRequestBody;

}



export type LoginRequestBody = {
  
  /**
  * Password for the account.
  * Required
  *  Must be non-empty
  */
  Password: string;

  /**
  * User ID for the account. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  UserId: string;

}






export function ValidateLoginRequest(req: LoginRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateLoginRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  

  

  return null;
}


function ValidateLoginRequestBody(o: LoginRequestBody) : IIMPError | null {
  
  
  
  if (o.Password.trim() === "") {
    throw new Error("Field 'Password' must be non-empty");
  }
  
  
  
  
  
  
  if (o.UserId.trim() === "") {
    throw new Error("Field 'UserId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type Login200Response = {
  

  
}




export async function NewLogin200Response(resp: Response): Promise<Login200Response> {
  var result = {} as Login200Response;

  

  
  return result
}


export type Login400Response = {
  

  
}




export async function NewLogin400Response(resp: Response): Promise<Login400Response> {
  var result = {} as Login400Response;

  

  
  return result
}


export type Login401Response = {
  

  
}




export async function NewLogin401Response(resp: Response): Promise<Login401Response> {
  var result = {} as Login401Response;

  

  
  return result
}


export type Login500Response = {
  

  
}




export async function NewLogin500Response(resp: Response): Promise<Login500Response> {
  var result = {} as Login500Response;

  

  
  return result
}




const LogoutRequestHTTPMethod = "POST";
const LogoutRequestRoutePath   = "/api/client/logout";

/**
 * Log out the current user and invalidate the session.
 */
export type LogoutRequest = {




  /**
  * Authentication parameters
  */
  Auth: LogoutRequestAuthParams;


}




export type LogoutRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateLogoutRequest(req: LogoutRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}







export type Logout204Response = {
  

  
}




export async function NewLogout204Response(resp: Response): Promise<Logout204Response> {
  var result = {} as Logout204Response;

  

  
  return result
}


export type Logout401Response = {
  

  
}




export async function NewLogout401Response(resp: Response): Promise<Logout401Response> {
  var result = {} as Logout401Response;

  

  
  return result
}


export type Logout500Response = {
  

  
}




export async function NewLogout500Response(resp: Response): Promise<Logout500Response> {
  var result = {} as Logout500Response;

  

  
  return result
}




const MessageFederationRequestHTTPMethod = "POST";
const MessageFederationRequestRoutePath   = "/api/federation/conversations/{conversationId}/messages";

/**
 * \"FEDERATION\" Send a new message/update to an existing message model to a conversation from another server. This endpoint is used by other servers to send messages to a conversation that includes users from the local server. The request will include details about the message and its sender. Upsert operation must be performed by the receiving server.
 */
export type MessageFederationRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * Unique identifier of the conversation to send the message to.
  * 
  * Required
  */
  ConversationId: string;





  /**
  * Authentication parameters
  */
  Auth: MessageFederationRequestAuthParams;


  /**
  * Request body
  */
  Body: MessageFederationRequestBody;

}



export type MessageFederationRequestBody = {
  
  /**
  * An optional list of attachments included with the message. Each attachment can be a file, image, or other media type that is associated with the message. The server will store the attachments and deliver them to the recipients along with the message content.
  * Optional
  * 
  */
  Attachments: Array<string>;

  /**
  * A list of message contents for the message, ordered by their version in Ascending Order. The original message sent by the client will have version 1. Each time the message is edited, a new MessageContent object is added to this list with the version number incremented by 1. This allows the server and clients to maintain a history of edits for each message, enabling features such as edit history viewing and audit trails.
  * Required
  *  Must be non-empty
  */
  Contents: Array<MessageFederationRequestBodyContentsItem>;

  /**
  * The unique identifier of the conversation that the message belongs to. This is typically a UUIDv7.
  * Required
  *  Must be non-empty
  */
  ConversationId: string;

  /**
  * A flag indicating whether the message has been redacted. Redaction is the process of removing or obscuring the content of a message while retaining its metadata (e.g., sender, timestamp) for record-keeping purposes. A redacted message will have its content removed or replaced with a placeholder value, and the IsRedacted flag will be set to true.
  * Required
  * 
  */
  IsRedacted: boolean;

  /**
  * A unique identifier for the message, typically a UUIDv7.
  * Required
  *  Must be non-empty
  */
  MessageId: string;

  /**
  * User ID of the sender of the message. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  SenderUserId: string;

  /**
  * The timestamp when the message was originally sent. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). This field is included to provide context about when the message was sent, which can be useful for ordering messages and displaying timestamps in the client applications.
  * Required
  *  Must be non-empty
  */
  Timestamp: string;

  /**
  * An array of per-user data for each recipient of the message.
  * Required
  *  Must be non-empty
  */
  UserSpecificData: Array<MessageFederationRequestBodyUserSpecificDataItem>;

}



export type MessageFederationRequestBodyContentsItem = {
  
  /**
  * No description provided
  * Required
  * 
  */
  MessageContent: MessageFederationRequestBodyContentsItemMessageContent;

  /**
  * The version of the message, to support message editing. The original message sent by the client will have version 1. Each time the message is edited, a new MessageContent object is added in the contents array with the version number incremented by 1. This allows the server and clients to maintain a history of edits for each message, enabling features such as edit history viewing and audit trails.
  * Required
  * 
  */
  Version: number;

}



export type MessageFederationRequestBodyContentsItemMessageContent = {
  
  /**
  * The content of the message to be sent in the conversation. The content should be encrypted using an AES key, and the AES key should be encrypted for each recipient using their respective public keys. The server will store the encrypted message content and the encrypted keys for each recipient, allowing the recipients to decrypt the AES key using their private keys and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  Content: string;

  /**
  * Encryption details for the recipients of the message.
  * Required
  *  Must be non-empty
  */
  EncryptionData: Array<MessageFederationRequestBodyContentsItemMessageContentEncryptionDataItem>;

  /**
  * The nonce (or initialization vector) used in the AES encryption of the message content. This should be a unique value for each message encrypted with the same AES key to ensure security. The nonce is required for the decryption process, as it is used along with the AES key to decrypt the message content. The server will store the nonce along with the encrypted message content and deliver it to the recipients, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  Nonce: string;

  /**
  * The timestamp when the message content was created. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). This field is included to provide context about when the message content was created, which can be useful for ordering messages and displaying timestamps in the client applications.
  * Required
  *  Must be non-empty
  */
  Timestamp: string;

}



export type MessageFederationRequestBodyContentsItemMessageContentEncryptionDataItem = {
  
  /**
  * Encryption details for a recipient of the message.
  * Required
  * 
  */
  Encryption: MessageFederationRequestBodyContentsItemMessageContentEncryptionDataItemEncryption;

  /**
  * User ID of the recipient of the message. (localpart@domain). This field is included to associate the encryption details with the specific recipient, allowing the server to deliver the correct encrypted key and nonce to each recipient along with the encrypted message content.
  * Required
  *  Must be non-empty
  */
  RecipientId: string;

}



export type MessageFederationRequestBodyContentsItemMessageContentEncryptionDataItemEncryption = {
  
  /**
  * The AES key used to encrypt the message content, encrypted with the recipient's public key using an asymmetric encryption algorithm (X25519 + HKDF). The server will store this encrypted key and deliver it to the recipient along with the encrypted message content, allowing the recipient to decrypt the AES key using their private key and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  EncryptedKey: string;

  /**
  * The nonce used in the encryption of the AES key for this recipient. This should be a unique value for each encrypted key to ensure security. The server will store this nonce along with the encrypted key and deliver it to the recipient, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  EncryptedKeyNonce: string;

  /**
  * An ephemeral public key generated by the sender for this message, used in the encryption process (X25519).
  * Required
  *  Must be non-empty
  */
  EphemeralPublicKey: string;

  /**
  * The unique identifier of the public key that was used to encrypt the message for this recipient. This should correspond to a KeyId returned by the server when the client added their public keys.
  * Required
  *  Must be non-empty
  */
  KeyId: string;

}



export type MessageFederationRequestBodyUserSpecificDataItem = {
  
  /**
  * The timestamp when the recipient reacted to the message. This field is null if the recipient has not reacted to the message yet. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). This field is included to provide context about when each reaction was made for the message.
  * Optional
  * 
  */
  ReactedAt: string | null;

  /**
  * An optional reaction from the recipient for the message (e.g., "like", "love", "laugh", "sad", "angry", etc.). This field is included to provide message reaction functionality, allowing recipients to react to messages with predefined reactions. The server will store the reaction and deliver it to the sender and other recipients, allowing them to see the reactions for each message. Emoji-Only field.
  * Optional
  * 
  */
  Reaction: string | null;

  /**
  * The timestamp when the recipient read the message. This field is null if the recipient has not read the message yet. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). This field is included to provide read receipt functionality, allowing the sender to know when each recipient has read the message.
  * Optional
  * 
  */
  ReadAt: string | null;

  /**
  * User ID of the recipient of the message. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  RecipientId: string;

}




export type MessageFederationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: Server JWT signed with the requesting server's private key. This token is used for authenticating requests between servers during federation. The receiving server will verify the token using the requesting server's public key, which can be obtained from the requesting server's JWKS endpoint. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateMessageFederationRequest(req: MessageFederationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateMessageFederationRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateMessageFederationRequestBody(o: MessageFederationRequestBody) : IIMPError | null {
  
  
  
  
  
  
  if (o.Contents.length === 0) {
    throw new Error("Field 'Contents' must be non-empty");
  }
  
  
  
  for (let idx = 0; idx < o.Contents.length; idx++) {
    const item = o.Contents[idx];
    ValidateMessageFederationRequestBodyContentsItem(item);
  }
  
  
  
  
  if (o.ConversationId.trim() === "") {
    throw new Error("Field 'ConversationId' must be non-empty");
  }
  
  
  
  
  
  
  
  
  
  if (o.MessageId.trim() === "") {
    throw new Error("Field 'MessageId' must be non-empty");
  }
  
  
  
  
  
  
  if (o.SenderUserId.trim() === "") {
    throw new Error("Field 'SenderUserId' must be non-empty");
  }
  
  
  
  
  
  
  if (o.Timestamp.trim() === "") {
    throw new Error("Field 'Timestamp' must be non-empty");
  }
  
  
  
  
  
  
  if (o.UserSpecificData.length === 0) {
    throw new Error("Field 'UserSpecificData' must be non-empty");
  }
  
  
  
  for (let idx = 0; idx < o.UserSpecificData.length; idx++) {
    const item = o.UserSpecificData[idx];
    ValidateMessageFederationRequestBodyUserSpecificDataItem(item);
  }
  
  
  return null;
}

function ValidateMessageFederationRequestBodyContentsItem(o: MessageFederationRequestBodyContentsItem) : IIMPError | null {
  
  
  
  
  ValidateMessageFederationRequestBodyContentsItemMessageContent(o.MessageContent);
  
  
  
  
  
  
  return null;
}

function ValidateMessageFederationRequestBodyContentsItemMessageContent(o: MessageFederationRequestBodyContentsItemMessageContent) : IIMPError | null {
  
  
  
  if (o.Content.trim() === "") {
    throw new Error("Field 'Content' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptionData.length === 0) {
    throw new Error("Field 'EncryptionData' must be non-empty");
  }
  
  
  
  for (let idx = 0; idx < o.EncryptionData.length; idx++) {
    const item = o.EncryptionData[idx];
    ValidateMessageFederationRequestBodyContentsItemMessageContentEncryptionDataItem(item);
  }
  
  
  
  
  if (o.Nonce.trim() === "") {
    throw new Error("Field 'Nonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.Timestamp.trim() === "") {
    throw new Error("Field 'Timestamp' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateMessageFederationRequestBodyContentsItemMessageContentEncryptionDataItem(o: MessageFederationRequestBodyContentsItemMessageContentEncryptionDataItem) : IIMPError | null {
  
  
  
  
  ValidateMessageFederationRequestBodyContentsItemMessageContentEncryptionDataItemEncryption(o.Encryption);
  
  
  
  
  
  if (o.RecipientId.trim() === "") {
    throw new Error("Field 'RecipientId' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateMessageFederationRequestBodyContentsItemMessageContentEncryptionDataItemEncryption(o: MessageFederationRequestBodyContentsItemMessageContentEncryptionDataItemEncryption) : IIMPError | null {
  
  
  
  if (o.EncryptedKey.trim() === "") {
    throw new Error("Field 'EncryptedKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptedKeyNonce.trim() === "") {
    throw new Error("Field 'EncryptedKeyNonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EphemeralPublicKey.trim() === "") {
    throw new Error("Field 'EphemeralPublicKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.KeyId.trim() === "") {
    throw new Error("Field 'KeyId' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateMessageFederationRequestBodyUserSpecificDataItem(o: MessageFederationRequestBodyUserSpecificDataItem) : IIMPError | null {
  
  
  
  
  
  
  
  
  
  
  
  
  if (o.RecipientId.trim() === "") {
    throw new Error("Field 'RecipientId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type MessageFederation200Response = {
  

  
}




export async function NewMessageFederation200Response(resp: Response): Promise<MessageFederation200Response> {
  var result = {} as MessageFederation200Response;

  

  
  return result
}


export type MessageFederation400Response = {
  

  
}




export async function NewMessageFederation400Response(resp: Response): Promise<MessageFederation400Response> {
  var result = {} as MessageFederation400Response;

  

  
  return result
}


export type MessageFederation401Response = {
  

  
}




export async function NewMessageFederation401Response(resp: Response): Promise<MessageFederation401Response> {
  var result = {} as MessageFederation401Response;

  

  
  return result
}


export type MessageFederation403Response = {
  

  
}




export async function NewMessageFederation403Response(resp: Response): Promise<MessageFederation403Response> {
  var result = {} as MessageFederation403Response;

  

  
  return result
}


export type MessageFederation404Response = {
  

  
}




export async function NewMessageFederation404Response(resp: Response): Promise<MessageFederation404Response> {
  var result = {} as MessageFederation404Response;

  

  
  return result
}


export type MessageFederation500Response = {
  

  
}




export async function NewMessageFederation500Response(resp: Response): Promise<MessageFederation500Response> {
  var result = {} as MessageFederation500Response;

  

  
  return result
}




const MessageForwardFederationRequestHTTPMethod = "POST";
const MessageForwardFederationRequestRoutePath   = "/api/federation/conversations/{conversationId}/messages/forward";

/**
 * \"FEDERATION\" Forward an existing message to a conversation from another server.
 */
export type MessageForwardFederationRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * Unique identifier of the conversation to forward the message to.
  * 
  * Required
  */
  ConversationId: string;





  /**
  * Authentication parameters
  */
  Auth: MessageForwardFederationRequestAuthParams;


  /**
  * Request body
  */
  Body: MessageForwardFederationRequestBody;

}



export type MessageForwardFederationRequestBody = {
  
  /**
  * Message details.
  * Required
  * 
  */
  OriginalMessageRequest: MessageForwardFederationRequestBodyOriginalMessageRequest;

  /**
  * User ID of the sender of the forwarded message. This should be in the format localpart@domain and must belong to the requesting server.
  * Required
  *  Must be non-empty
  */
  SenderUserId: string;

}



export type MessageForwardFederationRequestBodyOriginalMessageRequest = {
  
  /**
  * An optional list of attachments to be included with the message. Each attachment can be a file, image, or other media type that is associated with the message. The server will store the attachments and deliver them to the recipients along with the message content.
  * Optional
  * 
  */
  Attachments: Array<string>;

  /**
  * The content of the message to be sent in the conversation. The content should be encrypted using an AES key, and the AES key should be encrypted for each recipient using their respective public keys. The server will store the encrypted message content and the encrypted keys for each recipient, allowing the recipients to decrypt the AES key using their private keys and then use it to decrypt the message content.
  * Required
  * 
  */
  MessageContent: MessageForwardFederationRequestBodyOriginalMessageRequestMessageContent;

}



export type MessageForwardFederationRequestBodyOriginalMessageRequestMessageContent = {
  
  /**
  * The content of the message to be sent in the conversation. The content should be encrypted using an AES key, and the AES key should be encrypted for each recipient using their respective public keys. The server will store the encrypted message content and the encrypted keys for each recipient, allowing the recipients to decrypt the AES key using their private keys and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  Content: string;

  /**
  * Encryption details for the recipients of the message.
  * Required
  *  Must be non-empty
  */
  EncryptionData: Array<MessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItem>;

  /**
  * The nonce (or initialization vector) used in the AES encryption of the message content. This should be a unique value for each message encrypted with the same AES key to ensure security. The nonce is required for the decryption process, as it is used along with the AES key to decrypt the message content. The server will store the nonce along with the encrypted message content and deliver it to the recipients, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  Nonce: string;

  /**
  * The timestamp when the message content was created. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). This field is included to provide context about when the message content was created, which can be useful for ordering messages and displaying timestamps in the client applications.
  * Required
  *  Must be non-empty
  */
  Timestamp: string;

}



export type MessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItem = {
  
  /**
  * Encryption details for a recipient of the message.
  * Required
  * 
  */
  Encryption: MessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItemEncryption;

  /**
  * User ID of the recipient of the message. (localpart@domain). This field is included to associate the encryption details with the specific recipient, allowing the server to deliver the correct encrypted key and nonce to each recipient along with the encrypted message content.
  * Required
  *  Must be non-empty
  */
  RecipientId: string;

}



export type MessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItemEncryption = {
  
  /**
  * The AES key used to encrypt the message content, encrypted with the recipient's public key using an asymmetric encryption algorithm (X25519 + HKDF). The server will store this encrypted key and deliver it to the recipient along with the encrypted message content, allowing the recipient to decrypt the AES key using their private key and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  EncryptedKey: string;

  /**
  * The nonce used in the encryption of the AES key for this recipient. This should be a unique value for each encrypted key to ensure security. The server will store this nonce along with the encrypted key and deliver it to the recipient, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  EncryptedKeyNonce: string;

  /**
  * An ephemeral public key generated by the sender for this message, used in the encryption process (X25519).
  * Required
  *  Must be non-empty
  */
  EphemeralPublicKey: string;

  /**
  * The unique identifier of the public key that was used to encrypt the message for this recipient. This should correspond to a KeyId returned by the server when the client added their public keys.
  * Required
  *  Must be non-empty
  */
  KeyId: string;

}




export type MessageForwardFederationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: Server JWT signed with the requesting server's private key. This token is used for authenticating requests between servers during federation. The receiving server will verify the token using the requesting server's public key, which can be obtained from the requesting server's JWKS endpoint. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateMessageForwardFederationRequest(req: MessageForwardFederationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateMessageForwardFederationRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateMessageForwardFederationRequestBody(o: MessageForwardFederationRequestBody) : IIMPError | null {
  
  
  
  
  ValidateMessageForwardFederationRequestBodyOriginalMessageRequest(o.OriginalMessageRequest);
  
  
  
  
  
  if (o.SenderUserId.trim() === "") {
    throw new Error("Field 'SenderUserId' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateMessageForwardFederationRequestBodyOriginalMessageRequest(o: MessageForwardFederationRequestBodyOriginalMessageRequest) : IIMPError | null {
  
  
  
  
  
  
  
  ValidateMessageForwardFederationRequestBodyOriginalMessageRequestMessageContent(o.MessageContent);
  
  
  
  return null;
}

function ValidateMessageForwardFederationRequestBodyOriginalMessageRequestMessageContent(o: MessageForwardFederationRequestBodyOriginalMessageRequestMessageContent) : IIMPError | null {
  
  
  
  if (o.Content.trim() === "") {
    throw new Error("Field 'Content' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptionData.length === 0) {
    throw new Error("Field 'EncryptionData' must be non-empty");
  }
  
  
  
  for (let idx = 0; idx < o.EncryptionData.length; idx++) {
    const item = o.EncryptionData[idx];
    ValidateMessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItem(item);
  }
  
  
  
  
  if (o.Nonce.trim() === "") {
    throw new Error("Field 'Nonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.Timestamp.trim() === "") {
    throw new Error("Field 'Timestamp' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateMessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItem(o: MessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItem) : IIMPError | null {
  
  
  
  
  ValidateMessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItemEncryption(o.Encryption);
  
  
  
  
  
  if (o.RecipientId.trim() === "") {
    throw new Error("Field 'RecipientId' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateMessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItemEncryption(o: MessageForwardFederationRequestBodyOriginalMessageRequestMessageContentEncryptionDataItemEncryption) : IIMPError | null {
  
  
  
  if (o.EncryptedKey.trim() === "") {
    throw new Error("Field 'EncryptedKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptedKeyNonce.trim() === "") {
    throw new Error("Field 'EncryptedKeyNonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EphemeralPublicKey.trim() === "") {
    throw new Error("Field 'EphemeralPublicKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.KeyId.trim() === "") {
    throw new Error("Field 'KeyId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type MessageForwardFederation200Response = {
  

  
}




export async function NewMessageForwardFederation200Response(resp: Response): Promise<MessageForwardFederation200Response> {
  var result = {} as MessageForwardFederation200Response;

  

  
  return result
}


export type MessageForwardFederation400Response = {
  

  
}




export async function NewMessageForwardFederation400Response(resp: Response): Promise<MessageForwardFederation400Response> {
  var result = {} as MessageForwardFederation400Response;

  

  
  return result
}


export type MessageForwardFederation401Response = {
  

  
}




export async function NewMessageForwardFederation401Response(resp: Response): Promise<MessageForwardFederation401Response> {
  var result = {} as MessageForwardFederation401Response;

  

  
  return result
}


export type MessageForwardFederation403Response = {
  

  
}




export async function NewMessageForwardFederation403Response(resp: Response): Promise<MessageForwardFederation403Response> {
  var result = {} as MessageForwardFederation403Response;

  

  
  return result
}


export type MessageForwardFederation404Response = {
  

  
}




export async function NewMessageForwardFederation404Response(resp: Response): Promise<MessageForwardFederation404Response> {
  var result = {} as MessageForwardFederation404Response;

  

  
  return result
}


export type MessageForwardFederation500Response = {
  

  
}




export async function NewMessageForwardFederation500Response(resp: Response): Promise<MessageForwardFederation500Response> {
  var result = {} as MessageForwardFederation500Response;

  

  
  return result
}




const NewAttachmentRequestHTTPMethod = "POST";
const NewAttachmentRequestRoutePath   = "/api/client/attachments";

/**
 * Upload an attachment to be included with a message.
 */
export type NewAttachmentRequest = {




  /**
  * Authentication parameters
  */
  Auth: NewAttachmentRequestAuthParams;


  /**
  * Request body
  */
  Body: NewAttachmentRequestBody;

}



export type NewAttachmentRequestBody = {
  
  /**
  * The MIME type of the attachment (e.g., "image/png", "application/pdf", etc.).
  * Required
  *  Must be non-empty
  */
  ContentType: string;

  /**
  * The original filename of the attachment.
  * Required
  *  Must be non-empty
  */
  Filename: string;

  /**
  * The size of the attachment in bytes. The server may enforce a maximum attachment size.
  * Required
  * 
  */
  Size: number;

}




export type NewAttachmentRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateNewAttachmentRequest(req: NewAttachmentRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateNewAttachmentRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateNewAttachmentRequestBody(o: NewAttachmentRequestBody) : IIMPError | null {
  
  
  
  if (o.ContentType.trim() === "") {
    throw new Error("Field 'ContentType' must be non-empty");
  }
  
  
  
  
  
  
  if (o.Filename.trim() === "") {
    throw new Error("Field 'Filename' must be non-empty");
  }
  
  
  
  
  
  
  
  return null;
}






export type NewAttachment201Response = {
  

  
  /**
   * Response body
   */
  Body: NewAttachment201ResponseBody;
  
}



export type NewAttachment201ResponseBody = {
  
  /**
  * A unique identifier for the attachment, typically a UUIDv7. This ID can be used to reference the attachment in future operations, such as including it in a message payload when sending a message with attachments. The server will store the attachment and deliver it to the recipients along with the message content.
  * Required
  *  Must be non-empty
  */
  AttachmentId: string;

}




export async function NewNewAttachment201Response(resp: Response): Promise<NewAttachment201Response> {
  var result = {} as NewAttachment201Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type NewAttachment400Response = {
  

  
}




export async function NewNewAttachment400Response(resp: Response): Promise<NewAttachment400Response> {
  var result = {} as NewAttachment400Response;

  

  
  return result
}


export type NewAttachment401Response = {
  

  
}




export async function NewNewAttachment401Response(resp: Response): Promise<NewAttachment401Response> {
  var result = {} as NewAttachment401Response;

  

  
  return result
}


export type NewAttachment413Response = {
  

  
}




export async function NewNewAttachment413Response(resp: Response): Promise<NewAttachment413Response> {
  var result = {} as NewAttachment413Response;

  

  
  return result
}


export type NewAttachment500Response = {
  

  
}




export async function NewNewAttachment500Response(resp: Response): Promise<NewAttachment500Response> {
  var result = {} as NewAttachment500Response;

  

  
  return result
}




const NewConversationRequestHTTPMethod = "POST";
const NewConversationRequestRoutePath   = "/api/client/conversations";

/**
 * Create a new conversation.
 */
export type NewConversationRequest = {




  /**
  * Authentication parameters
  */
  Auth: NewConversationRequestAuthParams;


  /**
  * Request body
  */
  Body: NewConversationRequestBody;

}



export type NewConversationRequestBody = {
  
  /**
  * A name for the conversation, which can be set by the client. This is not used for identification purposes and can be changed by the owner user at any time.
  * Optional
  * 
  */
  ConversationName: string | null;

  /**
  * A list of user IDs for the participants to be added to the conversation. For a Direct Conversation, this list must contain exactly 2 user IDs (owner + participant). For a Group Conversation, this list must contain at least 3 user IDs (owner + 2 others).
  * Required
  *  Must be non-empty
  */
  ParticipantUserIds: Array<string>;

}




export type NewConversationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateNewConversationRequest(req: NewConversationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateNewConversationRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateNewConversationRequestBody(o: NewConversationRequestBody) : IIMPError | null {
  
  
  
  
  
  
  if (o.ParticipantUserIds.length === 0) {
    throw new Error("Field 'ParticipantUserIds' must be non-empty");
  }
  
  
  
  
  return null;
}






export type NewConversation201Response = {
  

  
  /**
   * Response body
   */
  Body: NewConversation201ResponseBody;
  
}



export type NewConversation201ResponseBodyConversationParticipantsItem = {
  
  /**
  * The unique identifier of the conversation that the participant is part of. This is typically a UUIDv7.
  * Required
  *  Must be non-empty
  */
  ConversationId: string;

  /**
  * The timestamp when the participant joined the conversation. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z").
  * Required
  *  Must be non-empty
  */
  JoinedAt: string;

  /**
  * The timestamp when the participant was removed from the conversation. This field is null if the participant is still part of the conversation. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). A removed participant will not receive new messages in the conversation but can still access the conversation history up until the time they were removed. Owner CANNOT be removed from the conversation.
  * Optional
  * 
  */
  RemovedAt: string | null;

  /**
  * This is the display name of the participant at the time they joined the conversation. This is not updated if the user changes their display name later. This field is included to provide context about the participant's identity within the conversation, even if their global display name changes over time. During federation, the owner's server contacts the participant's server to fetch the current display name of the participant, which is then stored as UserDisplayName in the conversation participant list. This allows the conversation to maintain a consistent display name for the participant, even if they change their display name globally on their server.
  * Required
  *  Must be non-empty
  */
  UserDisplayName: string;

  /**
  * User ID of the participant. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  UserId: string;

}



export type NewConversation201ResponseBodyConversation = {
  
  /**
  * A unique identifier for the conversation, typically a UUIDv7.
  * Required
  *  Must be non-empty
  */
  ConversationId: string;

  /**
  * An optional name for the conversation, which can be set by the client. This is not used for identification purposes and can be changed by the owner user at any time.
  * Optional
  * 
  */
  ConversationName: string | null;

  /**
  * The user ID of the owner of the conversation. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  ConversationOwnerId: string;

  /**
  * The timestamp when the conversation was created. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z").
  * Required
  *  Must be non-empty
  */
  CreatedAt: string;

  /**
  * A list of participants in the conversation. The owner of the conversation is also included in this list. Participants can be added or removed by the owner user. Contains at least 2 participants (including the owner) for a Direct Conversation and >2 participants for a Group Conversation.
  * Required
  *  Must be non-empty
  */
  Participants: Array<NewConversation201ResponseBodyConversationParticipantsItem>;

}



export type NewConversation201ResponseBody = {
  
  /**
  * Details of the created conversation.
  * Optional
  * 
  */
  Conversation: NewConversation201ResponseBodyConversation | null;

}




export async function NewNewConversation201Response(resp: Response): Promise<NewConversation201Response> {
  var result = {} as NewConversation201Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type NewConversation400Response = {
  

  
}




export async function NewNewConversation400Response(resp: Response): Promise<NewConversation400Response> {
  var result = {} as NewConversation400Response;

  

  
  return result
}


export type NewConversation401Response = {
  

  
}




export async function NewNewConversation401Response(resp: Response): Promise<NewConversation401Response> {
  var result = {} as NewConversation401Response;

  

  
  return result
}


export type NewConversation403Response = {
  

  
}




export async function NewNewConversation403Response(resp: Response): Promise<NewConversation403Response> {
  var result = {} as NewConversation403Response;

  

  
  return result
}


export type NewConversation404Response = {
  

  
}




export async function NewNewConversation404Response(resp: Response): Promise<NewConversation404Response> {
  var result = {} as NewConversation404Response;

  

  
  return result
}


export type NewConversation500Response = {
  

  
}




export async function NewNewConversation500Response(resp: Response): Promise<NewConversation500Response> {
  var result = {} as NewConversation500Response;

  

  
  return result
}




const NewMessageRequestHTTPMethod = "POST";
const NewMessageRequestRoutePath   = "/api/client/conversations/{conversationId}/messages";

/**
 * Send a new message in a conversation.
 */
export type NewMessageRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * The unique identifier of the conversation to send the message in. This is typically a UUIDv7.
  * 
  * Required
  */
  ConversationId: string;





  /**
  * Authentication parameters
  */
  Auth: NewMessageRequestAuthParams;


  /**
  * Request body
  */
  Body: NewMessageRequestBody;

}



export type NewMessageRequestBody = {
  
  /**
  * An optional list of attachments to be included with the message. Each attachment can be a file, image, or other media type that is associated with the message. The server will store the attachments and deliver them to the recipients along with the message content.
  * Optional
  * 
  */
  Attachments: Array<string>;

  /**
  * The content of the message to be sent in the conversation. The content should be encrypted using an AES key, and the AES key should be encrypted for each recipient using their respective public keys. The server will store the encrypted message content and the encrypted keys for each recipient, allowing the recipients to decrypt the AES key using their private keys and then use it to decrypt the message content.
  * Required
  * 
  */
  MessageContent: NewMessageRequestBodyMessageContent;

}



export type NewMessageRequestBodyMessageContent = {
  
  /**
  * The content of the message to be sent in the conversation. The content should be encrypted using an AES key, and the AES key should be encrypted for each recipient using their respective public keys. The server will store the encrypted message content and the encrypted keys for each recipient, allowing the recipients to decrypt the AES key using their private keys and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  Content: string;

  /**
  * Encryption details for the recipients of the message.
  * Required
  *  Must be non-empty
  */
  EncryptionData: Array<NewMessageRequestBodyMessageContentEncryptionDataItem>;

  /**
  * The nonce (or initialization vector) used in the AES encryption of the message content. This should be a unique value for each message encrypted with the same AES key to ensure security. The nonce is required for the decryption process, as it is used along with the AES key to decrypt the message content. The server will store the nonce along with the encrypted message content and deliver it to the recipients, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  Nonce: string;

  /**
  * The timestamp when the message content was created. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). This field is included to provide context about when the message content was created, which can be useful for ordering messages and displaying timestamps in the client applications.
  * Required
  *  Must be non-empty
  */
  Timestamp: string;

}



export type NewMessageRequestBodyMessageContentEncryptionDataItem = {
  
  /**
  * Encryption details for a recipient of the message.
  * Required
  * 
  */
  Encryption: NewMessageRequestBodyMessageContentEncryptionDataItemEncryption;

  /**
  * User ID of the recipient of the message. (localpart@domain). This field is included to associate the encryption details with the specific recipient, allowing the server to deliver the correct encrypted key and nonce to each recipient along with the encrypted message content.
  * Required
  *  Must be non-empty
  */
  RecipientId: string;

}



export type NewMessageRequestBodyMessageContentEncryptionDataItemEncryption = {
  
  /**
  * The AES key used to encrypt the message content, encrypted with the recipient's public key using an asymmetric encryption algorithm (X25519 + HKDF). The server will store this encrypted key and deliver it to the recipient along with the encrypted message content, allowing the recipient to decrypt the AES key using their private key and then use it to decrypt the message content.
  * Required
  *  Must be non-empty
  */
  EncryptedKey: string;

  /**
  * The nonce used in the encryption of the AES key for this recipient. This should be a unique value for each encrypted key to ensure security. The server will store this nonce along with the encrypted key and deliver it to the recipient, allowing them to use it in the decryption process. The nonce should be generated securely (e.g., using a cryptographically secure random number generator) and should be of 12 bytes (96 bits) in length for AES-256-GCM encryption.
  * Required
  *  Must be non-empty
  */
  EncryptedKeyNonce: string;

  /**
  * An ephemeral public key generated by the sender for this message, used in the encryption process (X25519).
  * Required
  *  Must be non-empty
  */
  EphemeralPublicKey: string;

  /**
  * The unique identifier of the public key that was used to encrypt the message for this recipient. This should correspond to a KeyId returned by the server when the client added their public keys.
  * Required
  *  Must be non-empty
  */
  KeyId: string;

}




export type NewMessageRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateNewMessageRequest(req: NewMessageRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateNewMessageRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateNewMessageRequestBody(o: NewMessageRequestBody) : IIMPError | null {
  
  
  
  
  
  
  
  ValidateNewMessageRequestBodyMessageContent(o.MessageContent);
  
  
  
  return null;
}

function ValidateNewMessageRequestBodyMessageContent(o: NewMessageRequestBodyMessageContent) : IIMPError | null {
  
  
  
  if (o.Content.trim() === "") {
    throw new Error("Field 'Content' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptionData.length === 0) {
    throw new Error("Field 'EncryptionData' must be non-empty");
  }
  
  
  
  for (let idx = 0; idx < o.EncryptionData.length; idx++) {
    const item = o.EncryptionData[idx];
    ValidateNewMessageRequestBodyMessageContentEncryptionDataItem(item);
  }
  
  
  
  
  if (o.Nonce.trim() === "") {
    throw new Error("Field 'Nonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.Timestamp.trim() === "") {
    throw new Error("Field 'Timestamp' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateNewMessageRequestBodyMessageContentEncryptionDataItem(o: NewMessageRequestBodyMessageContentEncryptionDataItem) : IIMPError | null {
  
  
  
  
  ValidateNewMessageRequestBodyMessageContentEncryptionDataItemEncryption(o.Encryption);
  
  
  
  
  
  if (o.RecipientId.trim() === "") {
    throw new Error("Field 'RecipientId' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateNewMessageRequestBodyMessageContentEncryptionDataItemEncryption(o: NewMessageRequestBodyMessageContentEncryptionDataItemEncryption) : IIMPError | null {
  
  
  
  if (o.EncryptedKey.trim() === "") {
    throw new Error("Field 'EncryptedKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EncryptedKeyNonce.trim() === "") {
    throw new Error("Field 'EncryptedKeyNonce' must be non-empty");
  }
  
  
  
  
  
  
  if (o.EphemeralPublicKey.trim() === "") {
    throw new Error("Field 'EphemeralPublicKey' must be non-empty");
  }
  
  
  
  
  
  
  if (o.KeyId.trim() === "") {
    throw new Error("Field 'KeyId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type NewMessage201Response = {
  

  
  /**
   * Response body
   */
  Body: NewMessage201ResponseBody;
  
}



export type NewMessage201ResponseBody = {
  
  /**
  * A unique identifier for the message, typically a UUIDv7.
  * Required
  *  Must be non-empty
  */
  MessageId: string;

}




export async function NewNewMessage201Response(resp: Response): Promise<NewMessage201Response> {
  var result = {} as NewMessage201Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type NewMessage400Response = {
  

  
}




export async function NewNewMessage400Response(resp: Response): Promise<NewMessage400Response> {
  var result = {} as NewMessage400Response;

  

  
  return result
}


export type NewMessage401Response = {
  

  
}




export async function NewNewMessage401Response(resp: Response): Promise<NewMessage401Response> {
  var result = {} as NewMessage401Response;

  

  
  return result
}


export type NewMessage403Response = {
  

  
}




export async function NewNewMessage403Response(resp: Response): Promise<NewMessage403Response> {
  var result = {} as NewMessage403Response;

  

  
  return result
}


export type NewMessage404Response = {
  

  
}




export async function NewNewMessage404Response(resp: Response): Promise<NewMessage404Response> {
  var result = {} as NewMessage404Response;

  

  
  return result
}


export type NewMessage500Response = {
  

  
}




export async function NewNewMessage500Response(resp: Response): Promise<NewMessage500Response> {
  var result = {} as NewMessage500Response;

  

  
  return result
}




const ReactToMessageRequestHTTPMethod = "POST";
const ReactToMessageRequestRoutePath   = "/api/client/conversations/{conversationId}/messages/{messageId}/react";

/**
 * React to a message in a conversation.
 */
export type ReactToMessageRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * The unique identifier of the conversation that the message belongs to. This is typically a UUIDv7.
  * 
  * Required
  */
  ConversationId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * The unique identifier of the message to react to. This is typically a UUIDv7.
  * 
  * Required
  */
  MessageId: string;





  /**
  * Authentication parameters
  */
  Auth: ReactToMessageRequestAuthParams;


  /**
  * Request body
  */
  Body: ReactToMessageRequestBody;

}



export type ReactToMessageRequestBody = {
  
  /**
  * A reaction from the recipient of a message (e.g., "like", "love", "laugh", "sad", "angry", etc.). Emoji-Only field. Null to remove reaction.
  * Optional
  * 
  */
  Reaction: string | null;

}




export type ReactToMessageRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateReactToMessageRequest(req: ReactToMessageRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateReactToMessageRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateReactToMessageRequestBody(o: ReactToMessageRequestBody) : IIMPError | null {
  
  
  
  
  return null;
}






export type ReactToMessage200Response = {
  

  
}




export async function NewReactToMessage200Response(resp: Response): Promise<ReactToMessage200Response> {
  var result = {} as ReactToMessage200Response;

  

  
  return result
}


export type ReactToMessage400Response = {
  

  
}




export async function NewReactToMessage400Response(resp: Response): Promise<ReactToMessage400Response> {
  var result = {} as ReactToMessage400Response;

  

  
  return result
}


export type ReactToMessage401Response = {
  

  
}




export async function NewReactToMessage401Response(resp: Response): Promise<ReactToMessage401Response> {
  var result = {} as ReactToMessage401Response;

  

  
  return result
}


export type ReactToMessage403Response = {
  

  
}




export async function NewReactToMessage403Response(resp: Response): Promise<ReactToMessage403Response> {
  var result = {} as ReactToMessage403Response;

  

  
  return result
}


export type ReactToMessage404Response = {
  

  
}




export async function NewReactToMessage404Response(resp: Response): Promise<ReactToMessage404Response> {
  var result = {} as ReactToMessage404Response;

  

  
  return result
}


export type ReactToMessage500Response = {
  

  
}




export async function NewReactToMessage500Response(resp: Response): Promise<ReactToMessage500Response> {
  var result = {} as ReactToMessage500Response;

  

  
  return result
}




const ReactToMessageForwardFederationRequestHTTPMethod = "POST";
const ReactToMessageForwardFederationRequestRoutePath   = "/api/federation/conversations/{conversationId}/messages/{messageId}/react/forward";

/**
 * \"FEDERATION\" React to a message in a conversation on another server.
 */
export type ReactToMessageForwardFederationRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * Unique identifier of the conversation to react to the message in.
  * 
  * Required
  */
  ConversationId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * Unique identifier of the message to react to.
  * 
  * Required
  */
  MessageId: string;





  /**
  * Authentication parameters
  */
  Auth: ReactToMessageForwardFederationRequestAuthParams;


  /**
  * Request body
  */
  Body: ReactToMessageForwardFederationRequestBody;

}



export type ReactToMessageForwardFederationRequestBody = {
  
  /**
  * Original received reaction on the requesting server.
  * Optional
  * 
  */
  OriginalReaction: ReactToMessageForwardFederationRequestBodyOriginalReaction | null;

  /**
  * User ID of the user who made the reaction. This should be in the format localpart@domain and must belong to the requesting server.
  * Required
  *  Must be non-empty
  */
  ReactingUserId: string;

}



export type ReactToMessageForwardFederationRequestBodyOriginalReaction = {
  
  /**
  * A reaction from the recipient of a message (e.g., "like", "love", "laugh", "sad", "angry", etc.). Emoji-Only field. Null to remove reaction.
  * Optional
  * 
  */
  Reaction: string | null;

}




export type ReactToMessageForwardFederationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: Server JWT signed with the requesting server's private key. This token is used for authenticating requests between servers during federation. The receiving server will verify the token using the requesting server's public key, which can be obtained from the requesting server's JWKS endpoint. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateReactToMessageForwardFederationRequest(req: ReactToMessageForwardFederationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateReactToMessageForwardFederationRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateReactToMessageForwardFederationRequestBody(o: ReactToMessageForwardFederationRequestBody) : IIMPError | null {
  
  
  
  
  if (o.OriginalReaction) {
    ValidateReactToMessageForwardFederationRequestBodyOriginalReaction(o.OriginalReaction);
  }
  
  
  
  
  
  if (o.ReactingUserId.trim() === "") {
    throw new Error("Field 'ReactingUserId' must be non-empty");
  }
  
  
  
  
  return null;
}

function ValidateReactToMessageForwardFederationRequestBodyOriginalReaction(o: ReactToMessageForwardFederationRequestBodyOriginalReaction) : IIMPError | null {
  
  
  
  
  return null;
}






export type ReactToMessageForwardFederation200Response = {
  

  
}




export async function NewReactToMessageForwardFederation200Response(resp: Response): Promise<ReactToMessageForwardFederation200Response> {
  var result = {} as ReactToMessageForwardFederation200Response;

  

  
  return result
}


export type ReactToMessageForwardFederation400Response = {
  

  
}




export async function NewReactToMessageForwardFederation400Response(resp: Response): Promise<ReactToMessageForwardFederation400Response> {
  var result = {} as ReactToMessageForwardFederation400Response;

  

  
  return result
}


export type ReactToMessageForwardFederation401Response = {
  

  
}




export async function NewReactToMessageForwardFederation401Response(resp: Response): Promise<ReactToMessageForwardFederation401Response> {
  var result = {} as ReactToMessageForwardFederation401Response;

  

  
  return result
}


export type ReactToMessageForwardFederation403Response = {
  

  
}




export async function NewReactToMessageForwardFederation403Response(resp: Response): Promise<ReactToMessageForwardFederation403Response> {
  var result = {} as ReactToMessageForwardFederation403Response;

  

  
  return result
}


export type ReactToMessageForwardFederation404Response = {
  

  
}




export async function NewReactToMessageForwardFederation404Response(resp: Response): Promise<ReactToMessageForwardFederation404Response> {
  var result = {} as ReactToMessageForwardFederation404Response;

  

  
  return result
}


export type ReactToMessageForwardFederation500Response = {
  

  
}




export async function NewReactToMessageForwardFederation500Response(resp: Response): Promise<ReactToMessageForwardFederation500Response> {
  var result = {} as ReactToMessageForwardFederation500Response;

  

  
  return result
}




const ReadMessageRequestHTTPMethod = "POST";
const ReadMessageRequestRoutePath   = "/api/client/conversations/{conversationId}/messages/{messageId}/read";

/**
 * Mark a message as read by the authenticated user.
 */
export type ReadMessageRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * The unique identifier of the conversation that the message belongs to. This is typically a UUIDv7.
  * 
  * Required
  */
  ConversationId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * The unique identifier of the message to mark as read. This is typically a UUIDv7.
  * 
  * Required
  */
  MessageId: string;





  /**
  * Authentication parameters
  */
  Auth: ReadMessageRequestAuthParams;


}




export type ReadMessageRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateReadMessageRequest(req: ReadMessageRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}







export type ReadMessage200Response = {
  

  
}




export async function NewReadMessage200Response(resp: Response): Promise<ReadMessage200Response> {
  var result = {} as ReadMessage200Response;

  

  
  return result
}


export type ReadMessage400Response = {
  

  
}




export async function NewReadMessage400Response(resp: Response): Promise<ReadMessage400Response> {
  var result = {} as ReadMessage400Response;

  

  
  return result
}


export type ReadMessage401Response = {
  

  
}




export async function NewReadMessage401Response(resp: Response): Promise<ReadMessage401Response> {
  var result = {} as ReadMessage401Response;

  

  
  return result
}


export type ReadMessage403Response = {
  

  
}




export async function NewReadMessage403Response(resp: Response): Promise<ReadMessage403Response> {
  var result = {} as ReadMessage403Response;

  

  
  return result
}


export type ReadMessage404Response = {
  

  
}




export async function NewReadMessage404Response(resp: Response): Promise<ReadMessage404Response> {
  var result = {} as ReadMessage404Response;

  

  
  return result
}


export type ReadMessage500Response = {
  

  
}




export async function NewReadMessage500Response(resp: Response): Promise<ReadMessage500Response> {
  var result = {} as ReadMessage500Response;

  

  
  return result
}




const ReadMessageForwardFederationRequestHTTPMethod = "POST";
const ReadMessageForwardFederationRequestRoutePath   = "/api/federation/conversations/{conversationId}/messages/{messageId}/read/forward";

/**
 * \"FEDERATION\" Mark a message as read in a conversation on another server.
 */
export type ReadMessageForwardFederationRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * Unique identifier of the conversation to mark the message as read in.
  * 
  * Required
  */
  ConversationId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * Unique identifier of the message to mark as read.
  * 
  * Required
  */
  MessageId: string;





  /**
  * Authentication parameters
  */
  Auth: ReadMessageForwardFederationRequestAuthParams;


  /**
  * Request body
  */
  Body: ReadMessageForwardFederationRequestBody;

}



export type ReadMessageForwardFederationRequestBody = {
  
  /**
  * User ID of the user who read the message. This should be in the format localpart@domain and must belong to the requesting server.
  * Required
  *  Must be non-empty
  */
  ReaderUserId: string;

}




export type ReadMessageForwardFederationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: Server JWT signed with the requesting server's private key. This token is used for authenticating requests between servers during federation. The receiving server will verify the token using the requesting server's public key, which can be obtained from the requesting server's JWKS endpoint. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateReadMessageForwardFederationRequest(req: ReadMessageForwardFederationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateReadMessageForwardFederationRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateReadMessageForwardFederationRequestBody(o: ReadMessageForwardFederationRequestBody) : IIMPError | null {
  
  
  
  if (o.ReaderUserId.trim() === "") {
    throw new Error("Field 'ReaderUserId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type ReadMessageForwardFederation200Response = {
  

  
}




export async function NewReadMessageForwardFederation200Response(resp: Response): Promise<ReadMessageForwardFederation200Response> {
  var result = {} as ReadMessageForwardFederation200Response;

  

  
  return result
}


export type ReadMessageForwardFederation400Response = {
  

  
}




export async function NewReadMessageForwardFederation400Response(resp: Response): Promise<ReadMessageForwardFederation400Response> {
  var result = {} as ReadMessageForwardFederation400Response;

  

  
  return result
}


export type ReadMessageForwardFederation401Response = {
  

  
}




export async function NewReadMessageForwardFederation401Response(resp: Response): Promise<ReadMessageForwardFederation401Response> {
  var result = {} as ReadMessageForwardFederation401Response;

  

  
  return result
}


export type ReadMessageForwardFederation403Response = {
  

  
}




export async function NewReadMessageForwardFederation403Response(resp: Response): Promise<ReadMessageForwardFederation403Response> {
  var result = {} as ReadMessageForwardFederation403Response;

  

  
  return result
}


export type ReadMessageForwardFederation404Response = {
  

  
}




export async function NewReadMessageForwardFederation404Response(resp: Response): Promise<ReadMessageForwardFederation404Response> {
  var result = {} as ReadMessageForwardFederation404Response;

  

  
  return result
}


export type ReadMessageForwardFederation500Response = {
  

  
}




export async function NewReadMessageForwardFederation500Response(resp: Response): Promise<ReadMessageForwardFederation500Response> {
  var result = {} as ReadMessageForwardFederation500Response;

  

  
  return result
}




const RedactMessageRequestHTTPMethod = "POST";
const RedactMessageRequestRoutePath   = "/api/client/conversations/{conversationId}/messages/{messageId}/redact";

/**
 * Redact a message in a conversation. If this conversation is a Direct Conversation, only the sender of the message can redact it. If this conversation is a Group Conversation, only the sender of the message or the owner of the conversation can redact it.
 */
export type RedactMessageRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * The unique identifier of the conversation that the message belongs to. This is typically a UUIDv7.
  * 
  * Required
  */
  ConversationId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * The unique identifier of the message to redact. This is typically a UUIDv7.
  * 
  * Required
  */
  MessageId: string;





  /**
  * Authentication parameters
  */
  Auth: RedactMessageRequestAuthParams;


}




export type RedactMessageRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateRedactMessageRequest(req: RedactMessageRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}







export type RedactMessage200Response = {
  

  
}




export async function NewRedactMessage200Response(resp: Response): Promise<RedactMessage200Response> {
  var result = {} as RedactMessage200Response;

  

  
  return result
}


export type RedactMessage400Response = {
  

  
}




export async function NewRedactMessage400Response(resp: Response): Promise<RedactMessage400Response> {
  var result = {} as RedactMessage400Response;

  

  
  return result
}


export type RedactMessage401Response = {
  

  
}




export async function NewRedactMessage401Response(resp: Response): Promise<RedactMessage401Response> {
  var result = {} as RedactMessage401Response;

  

  
  return result
}


export type RedactMessage403Response = {
  

  
}




export async function NewRedactMessage403Response(resp: Response): Promise<RedactMessage403Response> {
  var result = {} as RedactMessage403Response;

  

  
  return result
}


export type RedactMessage404Response = {
  

  
}




export async function NewRedactMessage404Response(resp: Response): Promise<RedactMessage404Response> {
  var result = {} as RedactMessage404Response;

  

  
  return result
}


export type RedactMessage500Response = {
  

  
}




export async function NewRedactMessage500Response(resp: Response): Promise<RedactMessage500Response> {
  var result = {} as RedactMessage500Response;

  

  
  return result
}




const RedactMessageForwardFederationRequestHTTPMethod = "POST";
const RedactMessageForwardFederationRequestRoutePath   = "/api/federation/conversations/{conversationId}/messages/{messageId}/redact/forward";

/**
 * \"FEDERATION\" Redact a message in a conversation on another server.
 */
export type RedactMessageForwardFederationRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * Unique identifier of the conversation to redact the message in.
  * 
  * Required
  */
  ConversationId: string;


  /**
  * Source: path parameter "{messageId}"
  
  * Unique identifier of the message to redact.
  * 
  * Required
  */
  MessageId: string;





  /**
  * Authentication parameters
  */
  Auth: RedactMessageForwardFederationRequestAuthParams;


  /**
  * Request body
  */
  Body: RedactMessageForwardFederationRequestBody;

}



export type RedactMessageForwardFederationRequestBody = {
  
  /**
  * User ID of the sender of the message to redact. This should be in the format localpart@domain and must belong to the requesting server and should be equal to the sender's id on the receiving server's message.
  * Required
  *  Must be non-empty
  */
  SenderUserId: string;

}




export type RedactMessageForwardFederationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: Server JWT signed with the requesting server's private key. This token is used for authenticating requests between servers during federation. The receiving server will verify the token using the requesting server's public key, which can be obtained from the requesting server's JWKS endpoint. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateRedactMessageForwardFederationRequest(req: RedactMessageForwardFederationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateRedactMessageForwardFederationRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateRedactMessageForwardFederationRequestBody(o: RedactMessageForwardFederationRequestBody) : IIMPError | null {
  
  
  
  if (o.SenderUserId.trim() === "") {
    throw new Error("Field 'SenderUserId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type RedactMessageForwardFederation200Response = {
  

  
}




export async function NewRedactMessageForwardFederation200Response(resp: Response): Promise<RedactMessageForwardFederation200Response> {
  var result = {} as RedactMessageForwardFederation200Response;

  

  
  return result
}


export type RedactMessageForwardFederation400Response = {
  

  
}




export async function NewRedactMessageForwardFederation400Response(resp: Response): Promise<RedactMessageForwardFederation400Response> {
  var result = {} as RedactMessageForwardFederation400Response;

  

  
  return result
}


export type RedactMessageForwardFederation401Response = {
  

  
}




export async function NewRedactMessageForwardFederation401Response(resp: Response): Promise<RedactMessageForwardFederation401Response> {
  var result = {} as RedactMessageForwardFederation401Response;

  

  
  return result
}


export type RedactMessageForwardFederation403Response = {
  

  
}




export async function NewRedactMessageForwardFederation403Response(resp: Response): Promise<RedactMessageForwardFederation403Response> {
  var result = {} as RedactMessageForwardFederation403Response;

  

  
  return result
}


export type RedactMessageForwardFederation404Response = {
  

  
}




export async function NewRedactMessageForwardFederation404Response(resp: Response): Promise<RedactMessageForwardFederation404Response> {
  var result = {} as RedactMessageForwardFederation404Response;

  

  
  return result
}


export type RedactMessageForwardFederation500Response = {
  

  
}




export async function NewRedactMessageForwardFederation500Response(resp: Response): Promise<RedactMessageForwardFederation500Response> {
  var result = {} as RedactMessageForwardFederation500Response;

  

  
  return result
}




const RefreshSessionRequestHTTPMethod = "POST";
const RefreshSessionRequestRoutePath   = "/api/client/refresh-session";

/**
 * Refresh the session token.
 */
export type RefreshSessionRequest = {





  /**
  * Request body
  */
  Body: RefreshSessionRequestBody;

}



export type RefreshSessionRequestBody = {
  
  /**
  * A token used to refresh the session token when it expires.
  * Required
  *  Must be non-empty
  */
  RefreshToken: string;

}






export function ValidateRefreshSessionRequest(req: RefreshSessionRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateRefreshSessionRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  

  

  return null;
}


function ValidateRefreshSessionRequestBody(o: RefreshSessionRequestBody) : IIMPError | null {
  
  
  
  if (o.RefreshToken.trim() === "") {
    throw new Error("Field 'RefreshToken' must be non-empty");
  }
  
  
  
  
  return null;
}






export type RefreshSession200Response = {
  

  
}




export async function NewRefreshSession200Response(resp: Response): Promise<RefreshSession200Response> {
  var result = {} as RefreshSession200Response;

  

  
  return result
}


export type RefreshSession401Response = {
  

  
}




export async function NewRefreshSession401Response(resp: Response): Promise<RefreshSession401Response> {
  var result = {} as RefreshSession401Response;

  

  
  return result
}


export type RefreshSession500Response = {
  

  
}




export async function NewRefreshSession500Response(resp: Response): Promise<RefreshSession500Response> {
  var result = {} as RefreshSession500Response;

  

  
  return result
}




const RequestResetPasswordRequestHTTPMethod = "POST";
const RequestResetPasswordRequestRoutePath   = "/api/client/request-reset-password";

/**
 * Request a password reset for the user account.
 */
export type RequestResetPasswordRequest = {





  /**
  * Request body
  */
  Body: RequestResetPasswordRequestBody;

}



export type RequestResetPasswordRequestBody = {
  
  /**
  * User ID for the account.
  * Required
  *  Must be non-empty
  */
  UserId: string;

}






export function ValidateRequestResetPasswordRequest(req: RequestResetPasswordRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateRequestResetPasswordRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  

  

  return null;
}


function ValidateRequestResetPasswordRequestBody(o: RequestResetPasswordRequestBody) : IIMPError | null {
  
  
  
  if (o.UserId.trim() === "") {
    throw new Error("Field 'UserId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type RequestResetPassword200Response = {
  

  
}




export async function NewRequestResetPassword200Response(resp: Response): Promise<RequestResetPassword200Response> {
  var result = {} as RequestResetPassword200Response;

  

  
  return result
}


export type RequestResetPassword400Response = {
  

  
}




export async function NewRequestResetPassword400Response(resp: Response): Promise<RequestResetPassword400Response> {
  var result = {} as RequestResetPassword400Response;

  

  
  return result
}


export type RequestResetPassword500Response = {
  

  
}




export async function NewRequestResetPassword500Response(resp: Response): Promise<RequestResetPassword500Response> {
  var result = {} as RequestResetPassword500Response;

  

  
  return result
}




const ResetPasswordRequestHTTPMethod = "POST";
const ResetPasswordRequestRoutePath   = "/api/client/reset-password";

/**
 * Reset the password for the user account.
 */
export type ResetPasswordRequest = {





  /**
  * Request body
  */
  Body: ResetPasswordRequestBody;

}



export type ResetPasswordRequestBody = {
  
  /**
  * New password for the account.
  * Required
  *  Must be non-empty
  */
  NewPassword: string;

  /**
  * A token sent to the user's email address as part of the password reset process. This token is used to verify the password reset request.
  * Required
  *  Must be non-empty
  */
  ResetToken: string;

  /**
  * User ID for the account.
  * Required
  *  Must be non-empty
  */
  UserId: string;

}






export function ValidateResetPasswordRequest(req: ResetPasswordRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateResetPasswordRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  

  

  return null;
}


function ValidateResetPasswordRequestBody(o: ResetPasswordRequestBody) : IIMPError | null {
  
  
  
  if (o.NewPassword.trim() === "") {
    throw new Error("Field 'NewPassword' must be non-empty");
  }
  
  
  
  
  
  
  if (o.ResetToken.trim() === "") {
    throw new Error("Field 'ResetToken' must be non-empty");
  }
  
  
  
  
  
  
  if (o.UserId.trim() === "") {
    throw new Error("Field 'UserId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type ResetPassword200Response = {
  

  
}




export async function NewResetPassword200Response(resp: Response): Promise<ResetPassword200Response> {
  var result = {} as ResetPassword200Response;

  

  
  return result
}


export type ResetPassword401Response = {
  

  
}




export async function NewResetPassword401Response(resp: Response): Promise<ResetPassword401Response> {
  var result = {} as ResetPassword401Response;

  

  
  return result
}


export type ResetPassword500Response = {
  

  
}




export async function NewResetPassword500Response(resp: Response): Promise<ResetPassword500Response> {
  var result = {} as ResetPassword500Response;

  

  
  return result
}




const SignUpRequestHTTPMethod = "POST";
const SignUpRequestRoutePath   = "/api/client/signup";

/**
 * Register a new user account with the IIMP service.
 */
export type SignUpRequest = {





  /**
  * Request body
  */
  Body: SignUpRequestBody;

}



export type SignUpRequestBody = {
  
  /**
  * Optional display name for the user.
  * Optional
  * 
  */
  DisplayName: string | null;

  /**
  * Email address for the new account. This can be same as the user ID or a different email address. The email address will be used for account recovery.
  * Required
  *  Must be non-empty
  */
  Email: string;

  /**
  * Password for the new account.
  * Required
  *  Must be non-empty
  */
  Password: string;

  /**
  * Desired user ID for the new account. (localpart@domain). Domain must be the same as the server's domain.
  * Required
  *  Must be non-empty
  */
  UserId: string;

}






export function ValidateSignUpRequest(req: SignUpRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateSignUpRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  

  

  return null;
}


function ValidateSignUpRequestBody(o: SignUpRequestBody) : IIMPError | null {
  
  
  
  
  
  
  if (o.Email.trim() === "") {
    throw new Error("Field 'Email' must be non-empty");
  }
  
  
  
  
  
  
  if (o.Password.trim() === "") {
    throw new Error("Field 'Password' must be non-empty");
  }
  
  
  
  
  
  
  if (o.UserId.trim() === "") {
    throw new Error("Field 'UserId' must be non-empty");
  }
  
  
  
  
  return null;
}






export type SignUp201Response = {
  

  
}




export async function NewSignUp201Response(resp: Response): Promise<SignUp201Response> {
  var result = {} as SignUp201Response;

  

  
  return result
}


export type SignUp400Response = {
  

  
}




export async function NewSignUp400Response(resp: Response): Promise<SignUp400Response> {
  var result = {} as SignUp400Response;

  

  
  return result
}


export type SignUp409Response = {
  

  
}




export async function NewSignUp409Response(resp: Response): Promise<SignUp409Response> {
  var result = {} as SignUp409Response;

  

  
  return result
}


export type SignUp500Response = {
  

  
}




export async function NewSignUp500Response(resp: Response): Promise<SignUp500Response> {
  var result = {} as SignUp500Response;

  

  
  return result
}




const SyncUserEventsRequestHTTPMethod = "GET";
const SyncUserEventsRequestRoutePath   = "/api/client/events/sync";

/**
 * Fetch a list of events for the authenticated user.
 */
export type SyncUserEventsRequest = {


  /**
  * Source: query parameter "cursor"
  
  * A cursor (Monotonically increasing per-user sequence number) for pagination. The server will return events starting from this cursor. If not provided, the server will return all available events starting from the oldest event in the system. The response will include a next_cursor field that can be used to fetch the next page of results.
  * 
  * Optional
  */
  Cursor?: number | undefined;


  /**
  * Source: query parameter "limit"
  
  * The maximum number of events to return in the response. If not provided, the server will use a default limit (e.g., 50). The server may enforce a maximum limit (100) to prevent excessively large responses.
  * 
  * Optional
  */
  Limit?: number | undefined;




  /**
  * Authentication parameters
  */
  Auth: SyncUserEventsRequestAuthParams;


}




export type SyncUserEventsRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateSyncUserEventsRequest(req: SyncUserEventsRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}







export type SyncUserEvents200Response = {
  

  
  /**
   * Response body
   */
  Body: SyncUserEvents200ResponseBody;
  
}



export type SyncUserEvents200ResponseBodyEventsItem = {
  
  /**
  * The timestamp when the event was created. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z").
  * Required
  *  Must be non-empty
  */
  CreatedAt: string;

  /**
  * A unique identifier for the event (Monotonically increasing per-user sequence number).
  * Required
  * 
  */
  EventId: number;

  /**
  * The type of the event (e.g., "message_received", "conversation_created", etc.). This field can be used by the client to determine how to process the event. For a full list of event types and their corresponding payload structures, refer to the IIMP Client Events documentation [here](https://github.com/iim-protocol/iimp/tree/main/Events.md).
  * Required
  *  Must be non-empty
  */
  EventType: string;

  /**
  * An optional field containing additional data related to the event. The structure of this object can vary depending on the event type and must conform to the IIMP Client Events documentation. Clients should be designed to handle different payload structures based on the event type.
  * Optional
  * 
  */
  Payload: Record<string, any> | null;

}



export type SyncUserEvents200ResponseBody = {
  
  /**
  * A list of events for the authenticated user, if any available. The events are ordered by their EventId in Ascending Order. The server may return up to 'limit' events in the response. If there are more events available beyond the returned list, a 'next_cursor' field will be included in the response, which can be used to fetch the next page of results.
  * Required
  * 
  */
  Events: Array<SyncUserEvents200ResponseBodyEventsItem>;

  /**
  * A cursor for the next page of results, if available. This field will be included in the response if there are more events available beyond the returned list.
  * Optional
  * 
  */
  NextCursor: number | null;

}




export async function NewSyncUserEvents200Response(resp: Response): Promise<SyncUserEvents200Response> {
  var result = {} as SyncUserEvents200Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type SyncUserEvents401Response = {
  

  
}




export async function NewSyncUserEvents401Response(resp: Response): Promise<SyncUserEvents401Response> {
  var result = {} as SyncUserEvents401Response;

  

  
  return result
}


export type SyncUserEvents500Response = {
  

  
}




export async function NewSyncUserEvents500Response(resp: Response): Promise<SyncUserEvents500Response> {
  var result = {} as SyncUserEvents500Response;

  

  
  return result
}




const UpdateConversationRequestHTTPMethod = "PUT";
const UpdateConversationRequestRoutePath   = "/api/client/conversations/{conversationId}";

/**
 * Update an existing conversation. Only for Group Conversations, Direct Conversations cannot be updated.
 */
export type UpdateConversationRequest = {

  /**
  * Source: path parameter "{conversationId}"
  
  * The unique identifier of the conversation to update. This is typically a UUIDv7.
  * 
  * Required
  */
  ConversationId: string;





  /**
  * Authentication parameters
  */
  Auth: UpdateConversationRequestAuthParams;


  /**
  * Request body
  */
  Body: UpdateConversationRequestBody;

}



export type UpdateConversationRequestBody = {
  
  /**
  * An updated name for the conversation, which can be set by the client. This is not used for identification purposes and can be changed by the owner user at any time.
  * Optional
  * 
  */
  ConversationName: string | null;

  /**
  * A list of user IDs for the participants to be added to the conversation.
  * Optional
  * 
  */
  ParticipantUserIdsToAdd: Array<string>;

  /**
  * A list of user IDs for the participants to be removed from the conversation. The owner user cannot be removed from the conversation and should not be included in this list.
  * Optional
  * 
  */
  ParticipantUserIdsToRemove: Array<string>;

}




export type UpdateConversationRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateUpdateConversationRequest(req: UpdateConversationRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  
  // Validate request body
  const bodyValidationError = ValidateUpdateConversationRequestBody(req.Body);
  if (bodyValidationError) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}


function ValidateUpdateConversationRequestBody(o: UpdateConversationRequestBody) : IIMPError | null {
  
  
  
  
  
  
  
  
  
  
  return null;
}






export type UpdateConversation200Response = {
  

  
  /**
   * Response body
   */
  Body: UpdateConversation200ResponseBody;
  
}



export type UpdateConversation200ResponseBodyConversationParticipantsItem = {
  
  /**
  * The unique identifier of the conversation that the participant is part of. This is typically a UUIDv7.
  * Required
  *  Must be non-empty
  */
  ConversationId: string;

  /**
  * The timestamp when the participant joined the conversation. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z").
  * Required
  *  Must be non-empty
  */
  JoinedAt: string;

  /**
  * The timestamp when the participant was removed from the conversation. This field is null if the participant is still part of the conversation. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z"). A removed participant will not receive new messages in the conversation but can still access the conversation history up until the time they were removed. Owner CANNOT be removed from the conversation.
  * Optional
  * 
  */
  RemovedAt: string | null;

  /**
  * This is the display name of the participant at the time they joined the conversation. This is not updated if the user changes their display name later. This field is included to provide context about the participant's identity within the conversation, even if their global display name changes over time. During federation, the owner's server contacts the participant's server to fetch the current display name of the participant, which is then stored as UserDisplayName in the conversation participant list. This allows the conversation to maintain a consistent display name for the participant, even if they change their display name globally on their server.
  * Required
  *  Must be non-empty
  */
  UserDisplayName: string;

  /**
  * User ID of the participant. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  UserId: string;

}



export type UpdateConversation200ResponseBodyConversation = {
  
  /**
  * A unique identifier for the conversation, typically a UUIDv7.
  * Required
  *  Must be non-empty
  */
  ConversationId: string;

  /**
  * An optional name for the conversation, which can be set by the client. This is not used for identification purposes and can be changed by the owner user at any time.
  * Optional
  * 
  */
  ConversationName: string | null;

  /**
  * The user ID of the owner of the conversation. (localpart@domain)
  * Required
  *  Must be non-empty
  */
  ConversationOwnerId: string;

  /**
  * The timestamp when the conversation was created. Format => ISO 8601 (e.g., "2024-06-01T12:00:00Z").
  * Required
  *  Must be non-empty
  */
  CreatedAt: string;

  /**
  * A list of participants in the conversation. The owner of the conversation is also included in this list. Participants can be added or removed by the owner user. Contains at least 2 participants (including the owner) for a Direct Conversation and >2 participants for a Group Conversation.
  * Required
  *  Must be non-empty
  */
  Participants: Array<UpdateConversation200ResponseBodyConversationParticipantsItem>;

}



export type UpdateConversation200ResponseBody = {
  
  /**
  * Details of the updated conversation.
  * Optional
  * 
  */
  Conversation: UpdateConversation200ResponseBodyConversation | null;

}




export async function NewUpdateConversation200Response(resp: Response): Promise<UpdateConversation200Response> {
  var result = {} as UpdateConversation200Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type UpdateConversation400Response = {
  

  
}




export async function NewUpdateConversation400Response(resp: Response): Promise<UpdateConversation400Response> {
  var result = {} as UpdateConversation400Response;

  

  
  return result
}


export type UpdateConversation401Response = {
  

  
}




export async function NewUpdateConversation401Response(resp: Response): Promise<UpdateConversation401Response> {
  var result = {} as UpdateConversation401Response;

  

  
  return result
}


export type UpdateConversation403Response = {
  

  
}




export async function NewUpdateConversation403Response(resp: Response): Promise<UpdateConversation403Response> {
  var result = {} as UpdateConversation403Response;

  

  
  return result
}


export type UpdateConversation404Response = {
  

  
}




export async function NewUpdateConversation404Response(resp: Response): Promise<UpdateConversation404Response> {
  var result = {} as UpdateConversation404Response;

  

  
  return result
}


export type UpdateConversation500Response = {
  

  
}




export async function NewUpdateConversation500Response(resp: Response): Promise<UpdateConversation500Response> {
  var result = {} as UpdateConversation500Response;

  

  
  return result
}




const UploadAttachmentRequestHTTPMethod = "PUT";
const UploadAttachmentRequestRoutePath   = "/api/client/attachments/{attachmentId}/bytes";

/**
 * Upload the bytes of an attachment. The bytes go in the request body.
 */
export type UploadAttachmentRequest = {

  /**
  * Source: path parameter "{attachmentId}"
  
  * No description provided.
  * 
  * Required
  */
  AttachmentId: string;





  /**
  * Authentication parameters
  */
  Auth: UploadAttachmentRequestAuthParams;


}




export type UploadAttachmentRequestAuthParams = {
  
  
  /**
  * Required Authentication Method
  * Source: header "Authorization"
  *  Description: A token used to authenticate the client session. This token is obtained after a successful login and must be included in the header of subsequent requests to access protected resources. 
  *  Format (NOT ENFORCED): Bearer <JWT (RFC 7519)> 
  */
  Authorization?: string;
  
  

  
};



export function ValidateUploadAttachmentRequest(req: UploadAttachmentRequest) : IIMPError | null {
  if (!req) {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Request is required");
  }

  

  
  
  if (!req.Auth.Authorization || req.Auth.Authorization.trim() === "") {
    throw new IIMPError(IIMPErrorReasonInvalidRequest, "Missing required authentication parameter: Authorization");
  }
  
  

  

  return null;
}







export type UploadAttachment204Response = {
  

  
}




export async function NewUploadAttachment204Response(resp: Response): Promise<UploadAttachment204Response> {
  var result = {} as UploadAttachment204Response;

  

  
  return result
}


export type UploadAttachment400Response = {
  

  
}




export async function NewUploadAttachment400Response(resp: Response): Promise<UploadAttachment400Response> {
  var result = {} as UploadAttachment400Response;

  

  
  return result
}


export type UploadAttachment401Response = {
  

  
}




export async function NewUploadAttachment401Response(resp: Response): Promise<UploadAttachment401Response> {
  var result = {} as UploadAttachment401Response;

  

  
  return result
}


export type UploadAttachment403Response = {
  

  
}




export async function NewUploadAttachment403Response(resp: Response): Promise<UploadAttachment403Response> {
  var result = {} as UploadAttachment403Response;

  

  
  return result
}


export type UploadAttachment404Response = {
  

  
}




export async function NewUploadAttachment404Response(resp: Response): Promise<UploadAttachment404Response> {
  var result = {} as UploadAttachment404Response;

  

  
  return result
}


export type UploadAttachment409Response = {
  

  
}




export async function NewUploadAttachment409Response(resp: Response): Promise<UploadAttachment409Response> {
  var result = {} as UploadAttachment409Response;

  

  
  return result
}


export type UploadAttachment413Response = {
  

  
  /**
   * Response body
   */
  Body: UploadAttachment413ResponseBody;
  
}



export type UploadAttachment413ResponseBody = {
  
  /**
  * The total size of the attachment specified during creation in bytes.
  * Required
  * 
  */
  AttachmentSize: number;

}




export async function NewUploadAttachment413Response(resp: Response): Promise<UploadAttachment413Response> {
  var result = {} as UploadAttachment413Response;

  

  
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new IIMPError(IIMPErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  
  return result
}


export type UploadAttachment500Response = {
  

  
}




export async function NewUploadAttachment500Response(resp: Response): Promise<UploadAttachment500Response> {
  var result = {} as UploadAttachment500Response;

  

  
  return result
}



function parsenumberParam(value: string | null, name: string, required: boolean): number | undefined {
  if (required && (value === null || value.trim() === "")) {
    throw new Error(`Missing required number parameter: ${name}`);
  }
  if (value === null || value.trim() === "") {
    return undefined; // return default value
  }
  const parsed = Number(value);
  if (isNaN(parsed)) {
    throw new Error(`Failed to parse number parameter: ${value}`);
  }
  return parsed;
}

function parsebooleanParam(value: string | null, name: string, required: boolean): boolean | undefined {
  if (required && (value === null || value.trim() === "")) {
    throw new Error(`Missing required boolean parameter: ${name}`);
  }
  if (value === null || value.trim() === "") {
    return undefined; // return default value
  }
  if (value.toLowerCase() === "true") {
    return true;
  } else if (value.toLowerCase() === "false") {
    return false;
  } else {
    throw new Error(`Failed to parse boolean parameter: ${value}`);
  }
}

function parsestringParam(value: string | null, name: string, required: boolean): string | undefined {
  if (required && (value === null || value.trim() === "")) {
    throw new Error(`Missing required string parameter: ${name}`);
  }
  if (value === null || value.trim() === "") {
    return undefined; // return default value
  }
  return value;
}
